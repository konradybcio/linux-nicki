diff --git a/arch/arm/boot/dts/qcom-msm8930-lumia625.dts b/arch/arm/boot/dts/qcom-msm8930-lumia625.dts
new file mode 100644
index 00000000..6dd5e1f6
--- /dev/null
+++ b/arch/arm/boot/dts/qcom-msm8930-lumia625.dts
@@ -0,0 +1,881 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <dt-bindings/input/input.h>
+
+#include "qcom-msm8930.dtsi"
+
+/*
+missing: flash, camera, (status leds?), radio?,
+*/
+
+/ {
+	model = "Lumia 625";
+	compatible = "qcom,msm8930";
+
+	chosen {
+		bootargs = "cma=64m";
+		//linux,initrd-start = <0x82200000>;
+		//linux,initrd-end = <0x82a54f30>;
+	};
+
+	soc {
+		rpm@108000 {
+			regulators {
+				compatible = "qcom,rpm-pm8038-regulators";
+
+
+#if 1
+				vdd_l1-supply = <&pm8038_s2>;
+				vdd_l2_l20-supply = <&pm8038_s2>;
+				vdd_l12_l24_l26-supply = <&pm8038_s2>;
+				vdd_l16_l19-supply = <&pm8038_s3>;
+				vdd_l27-supply = <&pm8038_s3>;
+				vdd_l7_l11_l21_l23-supply = <&pm8038_s4>;
+				vin_lvs-supply = <&pm8038_l11>;
+				// vdd_l8?
+				// others on vph_pwr
+
+				s1 {
+					regulator-min-microvolt = <500000>;
+					regulator-max-microvolt = <1150000>;
+					qcom,switch-mode-frequency = <4800000>;
+					bias-pull-down;
+				};
+
+				s2 {
+					regulator-always-on;
+					regulator-min-microvolt = <1400000>;
+					regulator-max-microvolt = <1400000>;
+					qcom,switch-mode-frequency = <1600000>;
+					bias-pull-down;
+				};
+
+				s3 {
+					regulator-min-microvolt = <1150000>;
+					regulator-max-microvolt = <1150000>;
+					qcom,switch-mode-frequency = <3200000>;
+					bias-pull-down;
+				};
+
+				s4 {
+					regulator-always-on;
+					regulator-min-microvolt = <2200000>; // 1950000
+					regulator-max-microvolt = <2200000>;
+					qcom,switch-mode-frequency = <1600000>;
+					bias-pull-down;
+				};
+
+				l1 {
+					regulator-min-microvolt = <1300000>;
+					regulator-max-microvolt = <1300000>;
+					bias-pull-down;
+				};
+
+				l2 {
+					regulator-min-microvolt = <1200000>;
+					regulator-max-microvolt = <1200000>;
+					bias-pull-down;
+
+					regulator-system-load = <100000>;
+					regulator-allow-set-load;
+				};
+
+				l3 {
+					regulator-min-microvolt = <3075000>;
+					regulator-max-microvolt = <3075000>;
+					bias-pull-down;
+				};
+
+				l4 {
+					regulator-always-on;
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					bias-pull-down;
+
+					regulator-system-load = <10000>;
+					regulator-allow-set-load;
+				};
+
+				l8 {
+					regulator-always-on; // lcm
+					regulator-min-microvolt = <2800000>;
+					regulator-max-microvolt = <2800000>;
+					bias-pull-down;
+
+					regulator-system-load = <100000>;
+					regulator-allow-set-load;
+				};
+
+				l9 {
+					regulator-always-on; // accel + proxim, ts
+					regulator-min-microvolt = <2850000>;
+					regulator-max-microvolt = <2850000>;
+					bias-pull-down;
+				};
+
+				l10 {
+					regulator-min-microvolt = <2900000>;
+					regulator-max-microvolt = <2900000>;
+					bias-pull-down;
+				};
+
+				l11 {
+					regulator-always-on;
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					bias-pull-down;
+
+					regulator-system-load = <100000>;
+					regulator-allow-set-load;
+				};
+
+				l23 {
+					regulator-always-on;
+					// ss?
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					bias-pull-down;
+				};
+
+				l24 {
+					// ss?
+					regulator-min-microvolt = <500000>;
+					regulator-max-microvolt = <1150000>;
+					bias-pull-down;
+
+					regulator-system-load = <10000>;
+					regulator-allow-set-load;
+				};
+
+				lvs1 {
+					bias-pull-down;
+				};
+
+				lvs2 {
+					regulator-always-on; // accel + proxim, ts
+					bias-pull-down;
+				};
+
+				usb-switch {};
+
+				corner {
+					regulator-always-on;
+					// regulator-boot-on;
+					regulator-min-microvolt = <3>;
+					regulator-max-microvolt = <3>;
+				};
+#endif
+			};
+		};
+
+		vsdcc_fixed: vsdcc-regulator {
+			compatible = "regulator-fixed";
+			regulator-name = "SDCC Power";
+			regulator-min-microvolt = <2700000>;
+			regulator-max-microvolt = <2700000>;
+			regulator-always-on;
+		};
+
+		/* touch screen reset gpio
+		driver doesnt use reset gpio so keep it on always */
+		touch_reset {
+			compatible = "regulator-fixed";
+			regulator-name = "touch_reset";
+			gpio = <&msmgpio 52 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+			regulator-always-on;
+		};
+
+		amba {
+			/* eMMC */
+			sdcc1: sdcc@12400000 {
+				status = "okay";
+				vmmc-supply = <&vsdcc_fixed>; //
+			};
+		};
+
+#if 0
+		gpu: adreno-3xx@4300000 {
+			compatible =  "qcom,adreno-305.2", "qcom,adreno"; // or .0 ?
+			reg = <0x04300000 0x20000>;
+			reg-names = "kgsl_3d0_reg_memory";
+			interrupts = <GIC_SPI 80 0>;
+			interrupt-names = "kgsl_3d0_irq";
+			clock-names =
+			    "core_clk",
+			    "iface_clk",
+			    "mem_clk",
+			    "mem_iface_clk";
+			clocks =
+			    <&mmcc GFX3D_CLK>,
+			    <&mmcc GFX3D_AHB_CLK>,
+			    <&mmcc GFX3D_AXI_CLK>,
+			    <&mmcc MMSS_IMEM_AHB_CLK>;
+
+#if 1
+			iommus = <&gfx3d 0
+				  &gfx3d 1
+				  &gfx3d 2
+				  &gfx3d 3
+				  &gfx3d 4
+				  &gfx3d 5
+				  &gfx3d 6
+				  &gfx3d 7
+				  &gfx3d 8
+				  &gfx3d 9
+				  &gfx3d 10
+				  &gfx3d 11
+				  &gfx3d 12
+				  &gfx3d 13
+				  &gfx3d 14
+				  &gfx3d 15
+				  &gfx3d 16
+				  &gfx3d 17
+				  &gfx3d 18
+				  &gfx3d 19
+				  &gfx3d 20
+				  &gfx3d 21
+				  &gfx3d 22
+				  &gfx3d 23
+				  &gfx3d 24
+				  &gfx3d 25
+				  &gfx3d 26
+				  &gfx3d 27
+				  &gfx3d 28
+				  &gfx3d 29
+				  &gfx3d 30
+				  &gfx3d 31>;
+#endif
+
+			qcom,gpu-pwrlevels {
+				compatible = "qcom,gpu-pwrlevels";
+				qcom,gpu-pwrlevel@0 {
+					qcom,gpu-freq = <400000000>;
+				};
+				qcom,gpu-pwrlevel@1 {
+					qcom,gpu-freq = <27000000>;
+				};
+			};
+		};
+
+		mmss_sfpb: syscon@5700000 {
+			compatible = "syscon";
+			reg = <0x5700000 0x70>;
+		};
+
+		dsi0: mdss_dsi@4700000 {
+			compatible = "qcom,mdss-dsi-ctrl";
+			label = "MDSS DSI CTRL->0";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <GIC_SPI 82 0>;
+			reg = <0x04700000 0x200>;
+			reg-names = "dsi_ctrl";
+
+			clocks = <&mmcc DSI_M_AHB_CLK>,
+				<&mmcc DSI_S_AHB_CLK>,
+				<&mmcc AMP_AHB_CLK>,
+				<&mmcc DSI_CLK>,
+				<&mmcc DSI1_BYTE_CLK>,
+				<&mmcc DSI_PIXEL_CLK>,
+				<&mmcc DSI1_ESC_CLK>; /*
+				<&rpmcc RPM_SYS_FABRIC_A_CLK>,
+				<&rpmcc RPM_MMFPB_A_CLK>,
+				<&rpmcc RPM_EBI1_A_CLK>,
+				<&rpmcc RPM_DAYTONA_FABRIC_A_CLK>,
+				<&rpmcc RPM_CFPB_A_CLK>,
+				<&rpmcc RPM_APPS_FABRIC_A_CLK>; */
+			clock-names = "iface", "bus", "core_mmss",
+					"src", "byte", "pixel",
+					"core"; /*,
+			"sfab", "mmfpb", "ebi1", "dfab", "cfpb", "afab"; */
+
+			/*
+			sfab: 133333000
+mmfpb: 38400000
+ebi1: 533000000
+dfab/cfpb: 64000000
+afab: 533000000
+
+			*/
+
+			assigned-clocks = <&mmcc DSI1_BYTE_SRC>,
+					<&mmcc DSI1_ESC_SRC>,
+					<&mmcc DSI_SRC>,
+					<&mmcc DSI_PIXEL_SRC>;
+			assigned-clock-parents = <&dsi0_phy 0>,
+						<&dsi0_phy 0>,
+						<&dsi0_phy 1>,
+						<&dsi0_phy 1>;
+			// syscon-sfpb = <&mmss_sfpb>;
+			phys = <&dsi0_phy>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					dsi0_in: endpoint {
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dsi0_out: endpoint {
+					};
+				};
+			};
+		};
+
+
+		dsi0_phy: dsi-phy@4700200 {
+			compatible = "qcom,dsi-phy-28nm-8960";
+			#clock-cells = <1>;
+			#phy-cells = <0>;
+
+			reg = <0x04700200 0x100>,
+				<0x04700300 0x200>,
+				<0x04700500 0x5c>;
+			reg-names = "dsi_pll", "dsi_phy", "dsi_phy_regulator";
+			clock-names = "iface_clk";
+			clocks = <&mmcc DSI_M_AHB_CLK>;
+		};
+
+		mdp: mdp@5100000 {
+			compatible = "qcom,mdp4";
+			reg = <0x05100000 0xf0000>;
+			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&mmcc MDP_CLK>,
+				 <&mmcc MDP_AHB_CLK>,
+				 <&mmcc MDP_AXI_CLK>,
+				 <&mmcc MDP_LUT_CLK>,
+				 <&mmcc HDMI_TV_CLK>,
+				 <&mmcc MDP_TV_CLK>;
+			clock-names = "core_clk",
+				      "iface_clk",
+				      "bus_clk",
+				      "lut_clk",
+				      "hdmi_clk",
+				      "tv_clk";
+#if 1
+			iommus = <&mdp_port0 0
+				  &mdp_port0 2
+				  &mdp_port1 0
+				  &mdp_port1 2>;
+#endif
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					mdp_lvds_out: endpoint {
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					mdp_dsi1_out: endpoint {
+					};
+				};
+
+				port@2 {
+					reg = <2>;
+					mdp_dsi2_out: endpoint {
+					};
+				};
+
+				port@3 {
+					reg = <3>;
+					mdp_dtv_out: endpoint {
+					};
+				};
+			};
+		};
+
+		mdp@5100000 {
+			vdd-supply = <&pm8038_l23>;
+			status = "okay";
+			ports {
+				port@1 {
+					mdp_dsi1_out: endpoint {
+						remote-endpoint = <&dsi0_in>;
+					};
+				};
+			};
+		};
+
+		dsi0: mdss_dsi@4700000 {
+			status = "okay";
+			vdda-supply = <&pm8038_l2>; /*VDD_MIPI1 to 4*/
+			avdd-supply = <&pm8038_l8>;
+			vddio-supply = <&pm8038_l23>;
+
+			panel@0 {
+				reg = <0>;
+				compatible = "sharp,ls043t1le01-qhd";
+
+				reset-gpios = <&msmgpio 58 GPIO_ACTIVE_HIGH>;
+
+				pinctrl-names = "default";
+				pinctrl-0 = <&panel_pins>;
+
+				port {
+					panel_in: endpoint {
+						remote-endpoint = <&dsi0_out>;
+					};
+				};
+			};
+
+			ports {
+				port@0 {
+					dsi0_in: endpoint {
+						remote-endpoint = <&mdp_dsi1_out>;
+					};
+				};
+
+				port@1 {
+					dsi0_out: endpoint {
+						remote-endpoint = <&panel_in>;
+						data-lanes = <1 2>;
+					};
+				};
+			};
+		};
+
+		dsi-phy@4700200 {
+			status = "okay";
+			vddio-supply = <&pm8038_l23>;/*VDD_PLL2_1 to 7*/
+		};
+#endif
+
+#if 1
+		mdp_port0: iommu@7500000 {
+			compatible = "qcom,apq8064-iommu";
+			#iommu-cells = <1>;
+			clock-names =
+			    "smmu_pclk",
+			    "iommu_clk";
+			clocks =
+			    <&mmcc SMMU_AHB_CLK>,
+			    <&mmcc MDP_AXI_CLK>;
+			reg = <0x07500000 0x100000>;
+			interrupts =
+			    <GIC_SPI 63 0>,
+			    <GIC_SPI 64 0>;
+			qcom,ncb = <2>;
+		};
+
+		mdp_port1: iommu@7600000 {
+			compatible = "qcom,apq8064-iommu";
+			#iommu-cells = <1>;
+			clock-names =
+			    "smmu_pclk",
+			    "iommu_clk";
+			clocks =
+			    <&mmcc SMMU_AHB_CLK>,
+			    <&mmcc MDP_AXI_CLK>;
+			reg = <0x07600000 0x100000>;
+			interrupts =
+			    <GIC_SPI 61 0>,
+			    <GIC_SPI 62 0>;
+			qcom,ncb = <2>;
+		};
+
+		gfx3d: iommu@7c00000 {
+			compatible = "qcom,apq8064-iommu";
+			#iommu-cells = <1>;
+			clock-names =
+			    "smmu_pclk",
+			    "iommu_clk";
+			clocks =
+			    <&mmcc SMMU_AHB_CLK>,
+			    <&mmcc GFX3D_AXI_CLK>;
+			reg = <0x07c00000 0x100000>;
+			interrupts =
+			    <GIC_SPI 69 0>,
+			    <GIC_SPI 70 0>;
+			qcom,ncb = <3>;
+		};
+#endif
+
+		usb@12500000 {
+			status = "okay";
+			dr_mode = "otg";
+			ulpi {
+				phy {
+					v3p3-supply = <&pm8038_l3>;
+					v1p8-supply = <&pm8038_l4>;
+				};
+			};
+		};
+
+#if 1
+		riva-pil@3204000 {
+			status = "okay";
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&riva_wlan_pin_a>, <&riva_bt_pin_a>, <&riva_fm_pin_a>;
+		};
+#endif
+
+#if 0
+		camss: camss@4500000 {
+			compatible = "qcom,msm8064-camss";
+			reg =
+				<0x04800000 0x400>,
+				<0x04800400 0x400>,
+				// <0x04801800 0x400>,
+
+				<0x04800c00 0x400>,
+				<0x04801000 0x400>,
+				// <0x04801400 0x400>,
+
+				<0x04800800 0x400>,
+				<0x04500000 0x100000>;
+				// vpe <0x05300000 0x100000>
+			reg-names =
+				"csiphy0",
+				"csiphy1",
+				// "csiphy2",
+				"csid0",
+				"csid1",
+				// "csid2",
+				"ispif",
+				"vfe";
+				// "vpe";
+			interrupts =
+				<GIC_SPI 139 0>,
+				<GIC_SPI 140 0>,
+				// <GIC_SPI 228 0>,
+				<GIC_SPI 84 0>,
+				<GIC_SPI 83 0>,
+				// <GIC_SPI 227 0>,
+				<GIC_SPI 167 0>,
+				<GIC_SPI 48 0>;
+				// <GIC_SPI 47 0>;
+			interrupt-names =
+				"csiphy0",
+				"csiphy1",
+				// "csiphy2",
+				"csid0",
+				"csid1",
+				// "csid2",
+				"ispif",
+				"vfe";
+				// "vpe";
+			// power-domains = <&mmcc CAMSS_VFE_GDSC>;
+			clocks =
+				/* csid */
+				<&mmcc CSI_AHB_CLK>,
+				<&mmcc CSI0_CLK>, <&mmcc CSI0_PHY_CLK>,
+				<&mmcc CSI1_CLK>, <&mmcc CSI1_PHY_CLK>,
+				// <&mmcc CSI2_CLK>, <&mmcc CSI2_PHY_CLK>,
+
+				/* csiphy */
+				<&mmcc CSIPHY0_TIMER_CLK>,
+				<&mmcc CSIPHY1_TIMER_CLK>,
+				// <&mmcc CSIPHY2_TIMER_CLK>,
+
+				/* ispif */
+				<&mmcc CSI_PIX_CLK>, <&mmcc CSI_RDI_CLK>,
+				<&mmcc CSI_PIX1_CLK>,
+				<&mmcc CSI_RDI1_CLK>, <&mmcc CSI_RDI2_CLK>,
+
+				/* vfe */
+				<&mmcc VFE_CLK>,
+				<&mmcc VFE_CSI_CLK>,
+				<&mmcc VFE_AHB_CLK>,
+				<&mmcc VFE_AXI_CLK>;
+
+			clock-names = "csi_ahb",
+				"csi0", "csi0_phy",
+				"csi1", "csi1_phy",
+				"csi2", "csi2_phy",
+				"csiphy0_timer", "csiphy1_timer", "csiphy2_timer",
+
+				"csi_pix", "csi_rdi", "csi_pix1", "csi1_rdi1", "csi_rdi2",
+
+				"vfe", "csi_vfe", "vfe_ahb", "vfe_axi";
+
+			vdda-supply = <&pm8038_l2>;
+			// iommus = <...>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				/* port@0 {
+					reg = <0>;
+					csiphy0_ep: endpoint {
+						clock-lanes = <1>;
+						data-lanes = <0 2 3 4>;
+						remote-endpoint = <&imx179_ep>;
+					};
+				}; */
+			};
+		};
+#endif
+	};
+
+	/* regulators {
+		compatible = "simple-bus";
+
+		ext_l2: gpio-regulator@91 {
+			compatible = "regulator-fixed";
+			regulator-name = "ext_l2";
+			gpio = <&msmgpio 91 0>;
+			startup-delay-us = <10000>;
+			enable-active-high;
+		};
+	}; */
+};
+
+&msmgpio {
+	sdcc1_pins: sdcc1-pin-active {
+		clk {
+			pins = "sdc1_clk";
+			drive-strengh = <16>;
+			bias-disable;
+		};
+
+		cmd {
+			pins = "sdc1_cmd";
+			drive-strengh = <10>;
+			bias-pull-up;
+		};
+
+		data {
+			pins = "sdc1_data";
+			drive-strengh = <10>;
+			bias-pull-up;
+		};
+	};
+
+	ps_hold: ps_hold {
+		mux {
+			pins = "gpio108";
+			function = "ps_hold";
+		};
+	};
+
+	riva_fm_pin_a: riva-fm-active {
+		pins = "gpio26", "gpio27";
+		function = "fm";
+	};
+
+	riva_bt_pin_a: riva-bt-active {
+		pins = "gpio28", "gpio29", "gpio83"; // 1 extra ?
+		function = "bt";
+	};
+
+	riva_wlan_pin_a: riva-wlan-active {
+		pins = "gpio84", "gpio85", "gpio86", "gpio87", "gpio88";
+		function = "wlan";
+
+		drive-strength = <6>;
+		bias-pull-down;
+	};
+
+	i2c3_pins: i2c3 {
+		mux {
+			pins = "gpio16", "gpio17";
+			function = "gsbi3";
+		};
+
+		pinconf {
+			pins = "gpio16", "gpio17";
+			drive-strength = <16>;
+			bias-disable;
+		};
+	};
+
+	i2c3_pins_sleep: i2c3_pins_sleep {
+		mux {
+			pins = "gpio16", "gpio17";
+			function = "gpio";
+		};
+		pinconf {
+			pins = "gpio16", "gpio17";
+			drive-strength = <2>;
+			bias-disable = <0>;
+		};
+	};
+
+	i2c4_pins: i2c4 {
+		mux {
+			pins = "gpio20", "gpio21";
+			function = "gsbi4";
+		};
+
+		pinconf {
+			pins = "gpio20", "gpio21";
+			drive-strength = <16>;
+			bias-disable;
+		};
+	};
+
+	i2c4_pins_sleep: i2c4_pins_sleep {
+		mux {
+			pins = "gpio20", "gpio21";
+			function = "gpio";
+		};
+		pinconf {
+			pins = "gpio20", "gpio21";
+			drive-strength = <2>;
+			bias-disable = <0>;
+		};
+	};
+
+	i2c12_pins: i2c12 {
+		mux {
+			pins = "gpio44", "gpio45";
+			function = "gsbi12";
+		};
+
+		pinconf {
+			pins = "gpio44", "gpio45";
+			drive-strength = <16>;
+			bias-disable;
+		};
+	};
+
+	i2c12_pins_sleep: i2c4_pins_sleep {
+		mux {
+			pins = "gpio44", "gpio45";
+			function = "gsbi12";
+		};
+		pinconf {
+			pins = "gpio44", "gpio45";
+			drive-strength = <2>;
+			bias-disable = <0>;
+		};
+	};
+
+	apds_pins: apds_pins {
+		irq {
+			pins = "gpio49";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-up;
+		};
+	};
+
+	kxtnk_pins: kxtnk_pins {
+		irq {
+			pins = "gpio46", "gpio67";
+			function = "gpio";
+
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	panel_pins: panel_pins {
+		reset {
+			pins = "gpio58";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+
+	touch_pins: touch_pins {
+		reset {
+			pins = "gpio52";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+
+		irq {
+			pins = "gpio11";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+
+};
+
+
+&gsbi3 {
+	status = "okay";
+	qcom,crci = <GSBI_CRCI_QUP>;
+	qcom,mode = <GSBI_PROT_I2C>;
+};
+
+&gsbi4 {
+	status = "okay";
+	qcom,crci = <GSBI_CRCI_QUP>;
+	qcom,mode = <GSBI_PROT_I2C>;
+};
+
+&gsbi12 {
+	status = "okay";
+	qcom,crci = <GSBI_CRCI_QUP>;
+	qcom,mode = <GSBI_PROT_I2C>;
+};
+
+&gsbi3_i2c {
+	clock-frequency = <400000>;
+	qcom,src-freq = <24000000>;
+
+	synaptics@4b {
+		compatible = "syna,rmi4-i2c";
+		reg = <0x4b>;
+
+		interrupts-extended = <&msmgpio 11 IRQ_TYPE_EDGE_FALLING>;
+		vdd-supply = <&pm8038_l9>;
+		vio-supply = <&pm8038_lvs2>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&touch_pins>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		rmi4-f01@1 {
+			reg = <0x1>;
+			syna,nosleep-mode = <1>;
+		};
+
+		rmi4-f11@11 {
+			reg = <0x11>;
+			syna,sensor-type = <1>;
+		};
+	};
+};
+
+
+&gsbi4_i2c {
+	// cam: front, back, flash,
+};
+
+&gsbi12_i2c {
+	kxtnk@1e {
+		compatible = "kionix,kxcnl1010";
+		reg = <0x1e>;
+
+		interrupts-extended = <&msmgpio 46 IRQ_TYPE_EDGE_FALLING>,
+						      <&msmgpio 67 IRQ_TYPE_EDGE_FALLING>;
+
+		vdd-supply = <&pm8038_l9>;
+		vio-supply = <&pm8038_lvs2>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&kxtnk_pins>;
+	};
+
+	apds@39 {
+		compatible = "avago,apds990x";
+		reg = <0x39>;
+
+		interrupts-extended = <&msmgpio 49 IRQ_TYPE_EDGE_FALLING>;
+		vdd-supply = <&pm8038_l9>;
+		vled-supply = <&pm8038_l9>;
+		// pm8038_lvs2 effect ?
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&apds_pins>;
+	};
+};
diff --git a/arch/arm/boot/dts/qcom-msm8930.dtsi b/arch/arm/boot/dts/qcom-msm8930.dtsi
new file mode 100644
index 00000000..56ce508c
--- /dev/null
+++ b/arch/arm/boot/dts/qcom-msm8930.dtsi
@@ -0,0 +1,798 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+/include/ "skeleton.dtsi"
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/qcom,gcc-msm8960.h>
+#include <dt-bindings/reset/qcom,gcc-msm8960.h>
+#include <dt-bindings/clock/qcom,mmcc-msm8960.h>
+#include <dt-bindings/clock/qcom,rpmcc.h>
+#include <dt-bindings/mfd/qcom-rpm.h>
+#include <dt-bindings/soc/qcom,gsbi.h>
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Qualcomm MSM8930";
+	compatible = "qcom,msm8930";
+	interrupt-parent = <&intc>;
+
+	memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		reg = <0x80000000 0x20000000>;
+	};
+
+
+#if 0
+00000000  80 20 00 00 08 c0 00 00  8e c0 00 00 00 40 00 00  |. ...........@..|
+00000010  8f 80 00 00 00 30 00 00  8f e0 00 00 00 10 00 00  |.....0..........|
+00000020  90 00 00 00 10 00 00 00                           |........|
+00000028
+#endif
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		smem_region: smem@80000000 {
+			reg = <0x80000000 0x200000>;
+			no-map;
+		};
+
+		wcnss_mem: wcnss@8f000000 {
+			reg = <0x8f000000 0x700000>;
+			no-map;
+		};
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		interrupts = <1 14 0x304>;
+
+		cpu@0 {
+			compatible = "qcom,krait";
+			enable-method = "qcom,kpss-acc-v1";
+			device_type = "cpu";
+			reg = <0>;
+			next-level-cache = <&L2>;
+			qcom,acc = <&acc0>;
+			qcom,saw = <&saw0>;
+		};
+
+		cpu@1 {
+			compatible = "qcom,krait";
+			enable-method = "qcom,kpss-acc-v1";
+			device_type = "cpu";
+			reg = <1>;
+			next-level-cache = <&L2>;
+			qcom,acc = <&acc1>;
+			qcom,saw = <&saw1>;
+		};
+
+		L2: l2-cache {
+			compatible = "cache";
+			cache-level = <2>;
+		};
+	};
+
+	cpu-pmu {
+		compatible = "qcom,krait-pmu";
+		interrupts = <1 10 0x304>;
+		qcom,no-pc-write; // TODO
+	};
+
+	clocks {
+		cxo_board: cxo_board {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <19200000>;
+			clock-output-names = "cxo_board";
+		};
+
+		pxo_board {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <27000000>;
+			clock-output-names = "pxo_board";
+		};
+
+		sleep_clk: sleep_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <32768>;
+			clock-output-names = "sleep_clk";
+		};
+	};
+
+	sfpb_mutex: hwmutex {
+		compatible = "qcom,sfpb-mutex";
+		syscon = <&sfpb_wrapper_mutex 0x604 0x4>;
+		#hwlock-cells = <1>;
+	};
+
+	smem {
+		compatible = "qcom,smem";
+		memory-region = <&smem_region>;
+
+		hwlocks = <&sfpb_mutex 3>;
+	};
+
+	smd {
+		compatible = "qcom,smd";
+
+		modem@0 {
+			interrupts = <0 37 IRQ_TYPE_EDGE_RISING>;
+
+			qcom,ipc = <&l2cc 8 3>;
+			qcom,smd-edge = <0>;
+
+			status = "disabled";
+		};
+
+		q6@1 {
+			interrupts = <0 90 IRQ_TYPE_EDGE_RISING>;
+
+			qcom,ipc = <&l2cc 8 15>;
+			qcom,smd-edge = <1>;
+
+			status = "disabled";
+		};
+
+		dsps@3 {
+			interrupts = <0 138 IRQ_TYPE_EDGE_RISING>;
+
+			qcom,ipc = <&sps_sic_non_secure 0x4080 0>;
+			qcom,smd-edge = <3>;
+
+			status = "disabled";
+		};
+
+		riva@6 {
+			interrupts = <0 198 IRQ_TYPE_EDGE_RISING>;
+
+			qcom,ipc = <&l2cc 8 25>;
+			qcom,smd-edge = <6>;
+
+			status = "disabled";
+		};
+	};
+
+	smsm {
+		compatible = "qcom,smsm";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		qcom,ipc-1 = <&l2cc 8 4>;
+		qcom,ipc-2 = <&l2cc 8 14>;
+		qcom,ipc-3 = <&l2cc 8 23>;
+		qcom,ipc-4 = <&sps_sic_non_secure 0x4094 0>;
+
+		apps_smsm: apps@0 {
+			reg = <0>;
+			#qcom,smem-state-cells = <1>;
+		};
+
+		modem_smsm: modem@1 {
+			reg = <1>;
+			interrupts = <0 38 IRQ_TYPE_EDGE_RISING>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		q6_smsm: q6@2 {
+			reg = <2>;
+			interrupts = <0 89 IRQ_TYPE_EDGE_RISING>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		wcnss_smsm: wcnss@3 {
+			reg = <3>;
+			interrupts = <0 204 IRQ_TYPE_EDGE_RISING>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		dsps_smsm: dsps@4 {
+			reg = <4>;
+			interrupts = <0 137 IRQ_TYPE_EDGE_RISING>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+	};
+
+	firmware {
+		scm {
+			compatible = "qcom,scm-apq8064";
+
+			// msm8960
+			// clocks = <&rpmcc RPM_DAYTONA_FABRIC_CLK>;
+			// clock-names = "core";
+		};
+	};
+
+	/*
+	 * These channels from the ADC are simply hardware monitors.
+	 * That is why the ADC is referred to as "HKADC" - HouseKeeping
+	 * ADC.
+	 */
+#if 0
+	iio-hwmon {
+		compatible = "iio-hwmon";
+		io-channels = <&xoadc 0x00 0x01>, /* Battery */
+			    <&xoadc 0x00 0x02>, /* DC in (charger) */
+			    <&xoadc 0x00 0x04>, /* VPH the main system voltage */
+			    <&xoadc 0x00 0x0b>, /* Die temperature */
+			    <&xoadc 0x00 0x0c>, /* Reference voltage 1.25V */
+			    <&xoadc 0x00 0x0d>, /* Reference voltage 0.625V */
+			    <&xoadc 0x00 0x0e>; /* Charger temperature */
+	};
+#endif
+
+	soc: soc {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		compatible = "simple-bus";
+
+		msmgpio: pinctrl@800000 {
+			compatible = "qcom,msm8960-pinctrl";
+			reg = <0x800000 0x4000>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			interrupts = <0 16 IRQ_TYPE_LEVEL_HIGH>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&ps_hold>;
+		};
+
+		sfpb_wrapper_mutex: syscon@1200000 {
+			compatible = "syscon";
+			reg = <0x01200000 0x8000>;
+		};
+
+		intc: interrupt-controller@2000000 {
+			compatible = "qcom,msm-qgic2";
+			interrupt-controller;
+			#interrupt-cells = <3>;
+			reg = <0x02000000 0x1000>,
+			      <0x02002000 0x1000>;
+		};
+
+		timer@200a000 {
+			compatible = "qcom,kpss-timer",
+				     "qcom,kpss-wdt-msm8960", "qcom,msm-timer";
+			interrupts = <1 1 0x301>,
+				     <1 2 0x301>,
+				     <1 3 0x301>;
+			reg = <0x0200a000 0x100>;
+			clock-frequency = <27000000>,
+					  <32768>;
+			cpu-offset = <0x80000>;
+		};
+
+		acc0: clock-controller@2088000 {
+			compatible = "qcom,kpss-acc-v1";
+			reg = <0x02088000 0x1000>, <0x02008000 0x1000>;
+		};
+
+		acc1: clock-controller@2098000 {
+			compatible = "qcom,kpss-acc-v1";
+			reg = <0x02098000 0x1000>, <0x02008000 0x1000>;
+		};
+
+		saw0: regulator@2089000 {
+			compatible = "qcom,saw2";
+			reg = <0x02089000 0x1000>, <0x02009000 0x1000>;
+			regulator;
+		};
+
+		saw1: regulator@2099000 {
+			compatible = "qcom,saw2";
+			reg = <0x02099000 0x1000>, <0x02009000 0x1000>;
+			regulator;
+		};
+
+		sps_sic_non_secure: sps-sic-non-secure@12100000 {
+			compatible	= "syscon";
+			reg		= <0x12100000 0x10000>;
+		};
+
+		// gsbi
+
+		gsbi3: gsbi@16200000 {
+			status = "disabled";
+			compatible = "qcom,gsbi-v1.0.0";
+			cell-index = <3>;
+			reg = <0x16200000 0x100>;
+			clocks = <&gcc GSBI3_H_CLK>;
+			clock-names = "iface";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+			gsbi3_i2c: i2c@16280000 {
+				compatible = "qcom,i2c-qup-v1.1.1";
+				pinctrl-0 = <&i2c3_pins>;
+				pinctrl-1 = <&i2c3_pins_sleep>;
+				pinctrl-names = "default", "sleep";
+				reg = <0x16280000 0x1000>;
+				interrupts = <GIC_SPI 151 IRQ_TYPE_NONE>;
+				clocks = <&gcc GSBI3_QUP_CLK>,
+					 <&gcc GSBI3_H_CLK>;
+				clock-names = "core", "iface";
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+		gsbi4: gsbi@16300000 {
+			status = "disabled";
+			compatible = "qcom,gsbi-v1.0.0";
+			cell-index = <4>;
+			reg = <0x16300000 0x03>;
+			clocks = <&gcc GSBI4_H_CLK>;
+			clock-names = "iface";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			gsbi4_i2c: i2c@16380000 {
+				compatible = "qcom,i2c-qup-v1.1.1";
+				pinctrl-0 = <&i2c4_pins>;
+				pinctrl-1 = <&i2c4_pins_sleep>;
+				pinctrl-names = "default", "sleep";
+				reg = <0x16380000 0x1000>;
+				interrupts = <GIC_SPI 153 IRQ_TYPE_NONE>;
+				clocks = <&gcc GSBI4_QUP_CLK>,
+					 <&gcc GSBI4_H_CLK>;
+				clock-names = "core", "iface";
+			};
+		};
+
+		gsbi12: gsbi@12480000 {
+			status = "disabled";
+			compatible = "qcom,gsbi-v1.0.0";
+			cell-index = <12>;
+			reg = <0x12480000 0x03>;
+			clocks = <&gcc GSBI12_H_CLK>;
+			clock-names = "iface";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			gsbi12_i2c: i2c@124a0000 {
+				compatible = "qcom,i2c-qup-v1.1.1";
+				pinctrl-0 = <&i2c12_pins>;
+				pinctrl-1 = <&i2c12_pins_sleep>;
+				pinctrl-names = "default", "sleep";
+				reg = <0x124a0000 0x1000>;
+				interrupts = <GIC_SPI 196 IRQ_TYPE_NONE>;
+				clocks = <&gcc GSBI12_QUP_CLK>,
+					 <&gcc GSBI12_H_CLK>;
+				clock-names = "core", "iface";
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+		rng@1a500000 {
+			compatible = "qcom,prng";
+			reg = <0x1a500000 0x200>;
+			clocks = <&gcc PRNG_CLK>;
+			clock-names = "core";
+		};
+
+		// ssbi c00000
+
+#if 1
+		qcom,ssbi@500000 {
+			compatible = "qcom,ssbi";
+			reg = <0x500000 0x1000>;
+			qcom,controller-type = "pmic-arbiter";
+
+			pmicintc: pmic@0 {
+				compatible = "qcom,pm8038";
+				interrupt-parent = <&msmgpio>;
+				interrupts = <104 8>;
+				#interrupt-cells = <2>;
+				interrupt-controller;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				pwrkey@1c {
+					compatible = "qcom,pm8921-pwrkey";
+					reg = <0x1c>;
+					interrupt-parent = <&pmicintc>;
+					interrupts = <50 1>, <51 1>;
+					debounce = <15625>;
+					pull-up;
+				};
+
+				vibrator@4a {
+					compatible = "qcom,pm8921-vib";
+					reg = <0x4a>;
+				};
+
+				/* keypad@148 {
+					compatible = "qcom,pm8921-keypad";
+					reg = <0x148>;
+					interrupt-parent = <&pmicintc>;
+					interrupts = <74 1>, <75 1>;
+					debounce = <15>;
+					scan-delay = <32>;
+					row-hold = <91500>;
+				}; */
+
+				rtc@11d {
+					compatible = "qcom,pm8921-rtc";
+					interrupt-parent = <&pmicintc>;
+					interrupts = <39 1>;
+					reg = <0x11d>;
+					allow-set-time;
+				};
+
+#if 1
+				wled@25A {
+					compatible = "qcom,pm8941-wled";
+					reg = <0x25A>;
+					label = "backlight";
+
+					// dig_mod_gen_en ?
+					// op_fdbck ?
+					qcom,cs-out;
+					qcom,current-limit = <25>;
+					qcom,current-boost-limit = <525>;
+					qcom,switching-freq = <1600>; // ?
+					qcom,ovp = <32>;
+					qcom,num-strings = <2>;
+				};
+#endif
+
+				/* xoadc: xoadc@197 {
+					compatible = "qcom,pm8038-adc";
+					reg = <197>;
+					interrupts-extended = <&pmicintc 78 IRQ_TYPE_EDGE_RISING>;
+					#address-cells = <2>;
+					#size-cells = <0>;
+					#io-channel-cells = <2>;
+
+					vcoin: adc-channel@00 {
+						reg = <0x00 0x00>;
+					};
+					vbat: adc-channel@01 {
+						reg = <0x00 0x01>;
+					};
+					dcin: adc-channel@02 {
+						reg = <0x00 0x02>;
+					};
+					ichg: adc-channel@03 {
+						reg = <0x00 0x03>;
+					};
+					vph_pwr: adc-channel@04 {
+						reg = <0x00 0x04>;
+					};
+					batt_therm: adc-channel@08 {
+						reg = <0x00 0x08>;
+					};
+					batt_id: adc-channel@09 {
+						reg = <0x00 0x09>;
+					};
+					usb_vbus: adc-channel@0a {
+						reg = <0x00 0x0a>;
+					};
+					die_temp: adc-channel@0b {
+						reg = <0x00 0x0b>;
+					};
+					ref_625mv: adc-channel@0c {
+						reg = <0x00 0x0c>;
+					};
+					ref_1250mv: adc-channel@0d {
+						reg = <0x00 0x0d>;
+					};
+					chg_temp: adc-channel@0e {
+						reg = <0x00 0x0e>;
+					};
+					ref_muxoff: adc-channel@0f {
+						reg = <0x00 0x0f>;
+					};
+				}; */
+
+				smbb: charger@0 {
+					compatible = "qcom,pm8941-charger";
+					reg = <0x0>;
+
+					interrupt-parent = <&pmicintc>;
+					interrupts =
+						<8 1>,  <9 1>,  <10 1>, <11 1>, <12 1>, <13 1>, <14 1>, <15 1>,
+						<16 1>, <17 1>, <18 1>, <19 1>, <20 1>, <21 1>, <22 1>, <23 1>,
+						<24 1>, <25 1>, <26 1>, <27 1>, <28 1>, <29 1>, <30 1>, <31 1>,
+						<40 1>, <41 1>, <42 1>, <43 1>, <44 1>, <45 1>,			<47 1>;
+					interrupt-names =
+						"vcp", "chg-wdog", "vbat-ov", "usb-uv", "vbatdet-low", "bat-insert", "usb-ov", "usb-valid",
+						"chg-trkl", "chg-fast", "loopchange", "chg-state", "chg-fail", "chg-done", "atc-fail", "atc-done",
+						"vdd-loop", "course-det-low", "bat-temp-ok", "chg-gone", "bat-temp-cold", "chg-hot", "bat-temp-hot", "bat-remove",
+						"dc-uv", "dc-ov", "dc-valid", "psi", "batfet", "vbatdet", "vreg-ov";
+
+					// usb-otg-in-supply = <&pm8941_5vs1>;
+
+					qcom,disable-dc;
+				// { "bat-present", smbb_bat_present_handler },
+
+					chg_otg: otg-vbus { };
+				};
+			};
+		};
+#endif
+
+		qfprom: qfprom@700000 {
+			compatible	= "qcom,qfprom";
+			reg		= <0x00700000 0x1000>;
+			#address-cells	= <1>;
+			#size-cells	= <1>;
+			ranges;
+			tsens_calib: calib {
+				reg = <0x404 0x10>;
+			};
+			tsens_backup: backup_calib {
+				reg = <0x414 0x10>;
+			};
+		};
+
+		/*
+		gcc: clock-controller@900000 {
+			compatible = "qcom,gcc-apq8064";
+			reg = <0x00900000 0x4000>;
+			nvmem-cells = <&tsens_calib>, <&tsens_backup>;
+			nvmem-cell-names = "calib", "calib_backup";
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			#thermal-sensor-cells = <1>;
+		};
+		*/
+
+		gcc: clock-controller@900000 {
+			compatible = "qcom,gcc-msm8960";
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			reg = <0x900000 0x4000>;
+		};
+
+		/*
+		lcc: clock-controller@28000000 {
+			compatible = "qcom,lcc-apq8064";
+			reg = <0x28000000 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+		*/
+
+		mmcc: clock-controller@4000000 {
+			compatible = "qcom,mmcc-msm8960";
+			reg = <0x4000000 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		l2cc: clock-controller@2011000 {
+			compatible	= "syscon";
+			reg		= <0x2011000 0x1000>;
+		};
+
+		rpm@108000 {
+			compatible	= "qcom,rpm-msm8930";
+			reg		= <0x108000 0x1000>;
+			qcom,ipc	= <&l2cc 0x8 2>;
+
+			interrupts	= <GIC_SPI 19 IRQ_TYPE_EDGE_RISING>,
+					  <GIC_SPI 21 IRQ_TYPE_EDGE_RISING>,
+					  <GIC_SPI 22 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names	= "ack", "err", "wakeup";
+
+			/* rpmcc: clock-controller {
+				compatible	= "qcom,rpmcc-msm8930", "qcom,rpmcc";
+				#clock-cells = <1>;
+			}; */
+
+			regulators {
+				compatible = "qcom,rpm-pm8038-regulators";
+
+				//pm8038_l3: l3 {};
+				//pm8038_l4: l4 {};
+#if 1
+				pm8038_s1: s1 {};
+				pm8038_s2: s2 {};
+				pm8038_s3: s3 {};
+				pm8038_s4: s4 {};
+
+				pm8038_l1: l1 {};
+				pm8038_l2: l2 {};
+				pm8038_l3: l3 {};
+				pm8038_l4: l4 {};
+				pm8038_l5: l5 {};
+				pm8038_l6: l6 {};
+				pm8038_l7: l7 {};
+				pm8038_l8: l8 {};
+				pm8038_l9: l9 {};
+				pm8038_l10: l10 {};
+				pm8038_l11: l11 {};
+				pm8038_l12: l12 {};
+				pm8038_l13: l13 {};
+				pm8038_l14: l14 {};
+				pm8038_l15: l15 {};
+				pm8038_l16: l16 {};
+				pm8038_l17: l17 {};
+				pm8038_l18: l18 {};
+				pm8038_l19: l19 {};
+				pm8038_l20: l20 {};
+				pm8038_l21: l21 {};
+				pm8038_l22: l22 {};
+				pm8038_l23: l23 {};
+				pm8038_l24: l24 {};
+				pm8038_l25: l25 {};
+				pm8038_l26: l26 {};
+
+				pm8038_lvs1: lvs1 {};
+				pm8038_lvs2: lvs2 {};
+
+				usb_switch: usb-switch {};
+				pm8038_corner: corner {};
+#endif
+			};
+		};
+
+		usb1: usb@12500000 {
+			compatible = "qcom,ci-hdrc";
+			reg = <0x12500000 0x200>,
+			      <0x12500200 0x200>;
+			interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc USB_HS1_XCVR_CLK>, <&gcc USB_HS1_H_CLK>;
+			clock-names = "core", "iface";
+			assigned-clocks = <&gcc USB_HS1_XCVR_CLK>;
+			assigned-clock-rates = <60000000>;
+			resets = <&gcc USB_HS1_RESET>;
+			reset-names = "core";
+			phy_type = "ulpi";
+			ahb-burst-config = <0>;
+			phys = <&usb_hs1_phy>;
+			phy-names = "usb-phy";
+			status = "disabled";
+			#reset-cells = <1>;
+
+			ulpi {
+				usb_hs1_phy: phy {
+					compatible = "qcom,usb-hs-phy-apq8064",
+						     "qcom,usb-hs-phy";
+					clocks = <&sleep_clk>, <&cxo_board>;
+					clock-names = "sleep", "ref";
+					resets = <&usb1 0>;
+					reset-names = "por";
+					#phy-cells = <0>;
+				};
+			};
+		};
+
+		//
+
+		sdcc1bam:dma@12402000{
+			compatible = "qcom,bam-v1.3.0";
+			reg = <0x12402000 0x8000>;
+			interrupts = <0 98 0>;
+			clocks = <&gcc SDC1_H_CLK>;
+			clock-names = "bam_clk";
+			#dma-cells = <1>;
+			qcom,ee = <0>;
+		};
+
+		amba {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+			sdcc1: sdcc@12400000 {
+				status		= "disabled";
+				compatible	= "arm,pl18x", "arm,primecell";
+				pinctrl-names	= "default";
+				pinctrl-0	= <&sdcc1_pins>;
+				arm,primecell-periphid = <0x00051180>;
+				reg		= <0x12400000 0x2000>;
+				interrupts	= <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names	= "cmd_irq";
+				clocks		= <&gcc SDC1_CLK>, <&gcc SDC1_H_CLK>;
+				clock-names	= "mclk", "apb_pclk";
+				bus-width	= <8>;
+				max-frequency	= <96000000>;
+				non-removable;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				dmas = <&sdcc1bam 2>, <&sdcc1bam 1>;
+				dma-names = "tx", "rx";
+			};
+		};
+
+#if 1
+		tcsr: syscon@1a400000 {
+			compatible = "qcom,tcsr-msm8960", "syscon";
+			reg = <0x1a400000 0x100>;
+		};
+
+		riva: riva-pil@3204000 {
+			compatible = "qcom,riva-pil";
+
+			reg = <0x03200800 0x1000>, <0x03202000 0x2000>, <0x03204000 0x100>;
+			reg-names = "ccu", "dxe", "pmu";
+
+			interrupts-extended = <&intc GIC_SPI 199 IRQ_TYPE_EDGE_RISING>,
+					      <&wcnss_smsm 6 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "wdog", "fatal";
+
+			memory-region = <&wcnss_mem>;
+
+			vddcx-supply = <&pm8038_s1>; // ?
+			vddmx-supply = <&pm8038_l24>; // ?
+			vddpx-supply = <&pm8038_l11>;
+
+			status = "disabled";
+
+			iris {
+				compatible = "qcom,wcn3660";
+
+				clocks = <&cxo_board>; // <&rpmcc RPM_CXO_CLK>;
+				clock-names = "xo";
+
+				vddxo-supply = <&pm8038_l4>;
+				vddrfa-supply = <&pm8038_l1>;
+				vddpa-supply = <&pm8038_l10>;
+				vdddig-supply = <&pm8038_l2>; // ?
+				// vddio l11
+			};
+
+			smd-edge {
+				interrupts = <GIC_SPI 198 IRQ_TYPE_EDGE_RISING>;
+
+				qcom,ipc = <&l2cc 8 25>;
+				qcom,smd-edge = <6>;
+
+				label = "riva";
+
+				wcnss {
+					compatible = "qcom,wcnss";
+					qcom,smd-channels = "WCNSS_CTRL";
+
+					qcom,mmio = <&riva>;
+
+					bt {
+						compatible = "qcom,wcnss-bt";
+						local-bd-address = [ 12 34 56 78 9a bc ];
+					};
+
+					wifi {
+						compatible = "qcom,wcnss-wlan";
+
+						interrupts = <GIC_SPI 203 IRQ_TYPE_LEVEL_HIGH>,
+							     <GIC_SPI 202 IRQ_TYPE_LEVEL_HIGH>;
+						interrupt-names = "tx", "rx";
+
+						qcom,smem-states = <&apps_smsm 10>, <&apps_smsm 9>;
+						qcom,smem-state-names = "tx-enable", "tx-rings-empty";
+
+						local-mac-address = [ 12 34 56 78 9a bd ];
+					};
+				};
+			};
+		};
+#endif
+	};
+};
diff --git a/drivers/clk/qcom/gcc-msm8960.c b/drivers/clk/qcom/gcc-msm8960.c
index eb551c75..945f2485 100644
--- a/drivers/clk/qcom/gcc-msm8960.c
+++ b/drivers/clk/qcom/gcc-msm8960.c
@@ -3420,6 +3420,30 @@ static const struct qcom_reset_map gcc_apq8064_resets[] = {
 	[USB_HS4_RESET] = { 0x3730 },
 };
 
+static struct clk_regmap *gcc_msm8930_clks[] = {
+	[PLL3] = &pll3.clkr,
+	[PLL4_VOTE] = &pll4_vote,
+	[PLL8] = &pll8.clkr,
+	[PLL8_VOTE] = &pll8_vote,
+	[PLL14] = &pll14.clkr,
+	[PLL14_VOTE] = &pll14_vote,
+
+	[SDC1_SRC] = &sdc1_src.clkr,
+	[SDC1_CLK] = &sdc1_clk.clkr,
+	[SDC1_H_CLK] = &sdc1_h_clk.clkr,
+
+	[USB_HS1_XCVR_SRC] = &usb_hs1_xcvr_src.clkr,
+	[USB_HS1_XCVR_CLK] = &usb_hs1_xcvr_clk.clkr,
+	[USB_HS1_H_CLK] = &usb_hs1_h_clk.clkr,
+};
+
+static const struct qcom_reset_map gcc_msm8930_resets[] = {
+	[SDC1_RESET] = { 0x2830 },
+
+	[USB_HS1_RESET] = { 0x2910 },
+	[USB_PHY0_RESET] = { 0x2E20 },
+};
+
 static const struct regmap_config gcc_msm8960_regmap_config = {
 	.reg_bits	= 32,
 	.reg_stride	= 4,
@@ -3436,6 +3460,14 @@ static const struct regmap_config gcc_apq8064_regmap_config = {
 	.fast_io	= true,
 };
 
+static const struct regmap_config gcc_msm8930_regmap_config = {
+	.reg_bits	= 32,
+	.reg_stride	= 4,
+	.val_bits	= 32,
+	.max_register	= 0x3880, // TODO
+	.fast_io	= true,
+};
+
 static const struct qcom_cc_desc gcc_msm8960_desc = {
 	.config = &gcc_msm8960_regmap_config,
 	.clks = gcc_msm8960_clks,
@@ -3452,9 +3484,18 @@ static const struct qcom_cc_desc gcc_apq8064_desc = {
 	.num_resets = ARRAY_SIZE(gcc_apq8064_resets),
 };
 
+static const struct qcom_cc_desc gcc_msm8930_desc = {
+	.config = &gcc_msm8930_regmap_config,
+	.clks = gcc_msm8930_clks,
+	.num_clks = ARRAY_SIZE(gcc_msm8930_clks),
+	.resets = gcc_msm8930_resets,
+	.num_resets = ARRAY_SIZE(gcc_msm8930_resets),
+};
+
 static const struct of_device_id gcc_msm8960_match_table[] = {
 	{ .compatible = "qcom,gcc-msm8960", .data = &gcc_msm8960_desc },
 	{ .compatible = "qcom,gcc-apq8064", .data = &gcc_apq8064_desc },
+	{ .compatible = "qcom,gcc-msm8930", .data = &gcc_msm8930_desc },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, gcc_msm8960_match_table);
@@ -3482,12 +3523,17 @@ static int gcc_msm8960_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	tsens = platform_device_register_data(&pdev->dev, "qcom-tsens", -1,
+	if (match->data == &gcc_apq8064_desc) {
+		hfpll1.d = &hfpll1_8064_data;
+		hfpll_l2.d = &hfpll_l2_8064_data;
+	}
+
+	/*tsens = platform_device_register_data(&pdev->dev, "qcom-tsens", -1,
 					      NULL, 0);
 	if (IS_ERR(tsens))
 		return PTR_ERR(tsens);
 
-	platform_set_drvdata(pdev, tsens);
+	platform_set_drvdata(pdev, tsens); */
 
 	return 0;
 }
diff --git a/drivers/clk/qcom/mmcc-msm8960.c b/drivers/clk/qcom/mmcc-msm8960.c
index 7f21421c..a3d6a572 100644
--- a/drivers/clk/qcom/mmcc-msm8960.c
+++ b/drivers/clk/qcom/mmcc-msm8960.c
@@ -3034,6 +3034,62 @@ static int mmcc_msm8960_probe(struct platform_device *pdev)
 	bool is_8064;
 	struct device *dev = &pdev->dev;
 
+
+	void *ptr = ioremap(0x4000000, 0x1000);
+	uint32_t tmp;
+
+	*(volatile uint32_t*) (ptr + 0x204) = 0x0;
+
+	tmp = *(volatile uint32_t*) (ptr + 0x008);
+	*(volatile uint32_t*) (ptr + 0x008) = (tmp & ~0x6C000103) | 0x40000000;
+
+	*(volatile uint32_t*) (ptr + 0x038) = 0x3C7097F9;
+
+	*(volatile uint32_t*) (ptr + 0x020C) = 0x0;
+	*(volatile uint32_t*) (ptr + 0x0200) = 0x0;
+
+#define rmw(x, v, m) ({ \
+	tmp = *(volatile uint32_t*) (ptr + x); \
+	*(volatile uint32_t*) (ptr + x) = (tmp & ~m) | v; \
+})
+
+	rmw(0x0018, 0x0003AFF9, 0x0803FFFF);
+	rmw(0x0020, 0x3A27FCFF, 0x3A3FFFFF);
+	rmw(0x002C, 0x0027FCFF, 0x003FFFFF);
+	rmw(0x0114, 0x0027FCFF, 0x017FFFFF);
+	rmw(0x0244, 0x000004FF, 0x00000FFF);
+
+	rmw(0x0030, 0x00003C38, 0x00003FFF);
+
+	rmw(0x0040, 0x00000000, 0x00000410);
+	rmw(0x0024, 0x00000000, 0x00000410);
+	rmw(0x0090, 0x80FF0000, 0xE0FF0010);
+	rmw(0x0130, 0x80FF0000, 0xE0FF0010);
+	rmw(0x0080, 0xC0FF0000, 0xE0FF0010);
+	rmw(0x0098, 0x80FF0000, 0xE0FF0010);
+	rmw(0x00C0, 0x80FF0000, 0xE1FF0010);
+	rmw(0x016C, 0x80FF0000, 0xE0FF0010);
+	rmw(0x00E0, 0x80FF0000, 0xE0FF0010);
+	rmw(0x0124, 0x000004FF, 0x000007FF);
+	rmw(0x00F8, 0xC0FF0000, 0xE0FF0010);
+	rmw(0x0104, 0x80FF0000, 0xE0FF4010);
+	rmw(0x023C, 0x800000FF, 0xE00000FF);
+	rmw(0x0110, 0x80FF0000, 0xE0FF0010);
+
+	rmw(0x00EC, 0x80FF0000, 0xE1FFC010);
+
+	//*(volatile uint32_t*) (ptr + 0x0210) = 0x0;
+	//*(volatile uint32_t*) (ptr + 0x0214) = 0x0;
+
+	*(volatile uint32_t*) (ptr + 0x0214) = BIT(11);
+	*(volatile uint32_t*) (ptr + 0x0214) = BIT(15);
+
+
+
+	rmw(0x00B0, 1, 7);
+	rmw(0x011C, 1, 7);
+
+
 	match = of_match_device(mmcc_msm8960_match_table, dev);
 	if (!match)
 		return -EINVAL;
@@ -3052,7 +3108,15 @@ static int mmcc_msm8960_probe(struct platform_device *pdev)
 
 	clk_pll_configure_sr(&pll15, regmap, &pll15_config, false);
 
-	return qcom_cc_really_probe(pdev, match->data, regmap);
+
+	int ret = qcom_cc_really_probe(pdev, match->data, regmap);
+
+	printk("a\n");
+	//clk_pll_ops.set_rate(&pll2.clkr.hw, 800000000, 27000000);
+	clk_pll_ops.enable(&pll2.clkr.hw);
+	printk("b\n");
+
+	return ret;
 }
 
 static struct platform_driver mmcc_msm8960_driver = {
diff --git a/drivers/gpu/drm/msm/disp/mdp4/mdp4_kms.c b/drivers/gpu/drm/msm/disp/mdp4/mdp4_kms.c
index 4b646bf9..01304e0e 100644
--- a/drivers/gpu/drm/msm/disp/mdp4/mdp4_kms.c
+++ b/drivers/gpu/drm/msm/disp/mdp4/mdp4_kms.c
@@ -561,7 +561,7 @@ static struct mdp4_platform_config *mdp4_get_config(struct platform_device *dev)
 	static struct mdp4_platform_config config = {};
 
 	/* TODO: Chips that aren't apq8064 have a 200 Mhz max_clk */
-	config.max_clk = 266667000;
+	config.max_clk = 200000000; //266667000;
 	config.iommu = iommu_domain_alloc(&platform_bus_type);
 	if (config.iommu) {
 		config.iommu->geometry.aperture_start = 0x1000;
diff --git a/drivers/mfd/qcom-pm8xxx.c b/drivers/mfd/qcom-pm8xxx.c
index f08758f6..adcd0b45 100644
--- a/drivers/mfd/qcom-pm8xxx.c
+++ b/drivers/mfd/qcom-pm8xxx.c
@@ -513,6 +513,7 @@ static const struct pm_irq_data pm8821_data = {
 
 static const struct of_device_id pm8xxx_id_table[] = {
 	{ .compatible = "qcom,pm8018", .data = &pm8xxx_data},
+	{ .compatible = "qcom,pm8038", .data = &pm8xxx_data},
 	{ .compatible = "qcom,pm8058", .data = &pm8xxx_data},
 	{ .compatible = "qcom,pm8821", .data = &pm8821_data},
 	{ .compatible = "qcom,pm8921", .data = &pm8xxx_data},
diff --git a/drivers/mfd/qcom_rpm.c b/drivers/mfd/qcom_rpm.c
index 52fafea0..23247076 100644
--- a/drivers/mfd/qcom_rpm.c
+++ b/drivers/mfd/qcom_rpm.c
@@ -256,6 +256,92 @@ static const struct qcom_rpm_data msm8660_template = {
 	.ack_sel_size = 7,
 };
 
+static const struct qcom_rpm_resource msm8930_rpm_resource_table[] = {
+	[QCOM_RPM_CXO_CLK] =			{ 25, 9, 5, 1 },
+	[QCOM_RPM_PXO_CLK] =			{ 26, 10, 6, 1 },
+	[QCOM_RPM_APPS_FABRIC_CLK] =	{ 27, 11, 8, 1 },
+	[QCOM_RPM_SYS_FABRIC_CLK] =		{ 28, 12, 9, 1 },
+	[QCOM_RPM_MM_FABRIC_CLK] =		{ 29, 13, 10, 1 },
+	[QCOM_RPM_DAYTONA_FABRIC_CLK] =	{ 30, 14, 11, 1 },
+	[QCOM_RPM_SFPB_CLK] =			{ 31, 15, 12, 1 },
+	[QCOM_RPM_CFPB_CLK] =			{ 32, 16, 13, 1 },
+	[QCOM_RPM_MMFPB_CLK] =			{ 33, 17, 14, 1 },
+	[QCOM_RPM_EBI1_CLK] =			{ 34, 18, 16, 1 },
+
+	[QCOM_RPM_APPS_FABRIC_HALT] =	{ 35, 19, 18, 1 },
+	[QCOM_RPM_APPS_FABRIC_MODE] =	{ 37, 20, 19, 1 },
+	[QCOM_RPM_APPS_FABRIC_IOCTL] =	{ 40, 21, 20, 1 },
+	[QCOM_RPM_APPS_FABRIC_ARB] =	{ 41, 22, 21, 6 },
+
+	[QCOM_RPM_SYS_FABRIC_HALT] =	{ 47, 23, 22, 1 },
+	[QCOM_RPM_SYS_FABRIC_MODE] =	{ 49, 24, 23, 1 },
+	[QCOM_RPM_SYS_FABRIC_IOCTL] =	{ 52, 25, 24, 1 },
+	[QCOM_RPM_SYS_FABRIC_ARB] =		{ 53, 26, 25, 20 },
+
+	[QCOM_RPM_MM_FABRIC_HALT] =		{ 73, 27, 26, 1 },
+	[QCOM_RPM_MM_FABRIC_MODE] =		{ 75, 28, 27, 1 },
+	[QCOM_RPM_MM_FABRIC_IOCTL] =	{ 78, 29, 28, 1 },
+	[QCOM_RPM_MM_FABRIC_ARB] =		{ 79, 30, 29, 11 },
+
+	[QCOM_RPM_PM8038_SMPS1] =		{ 90, 31, 30, 2 },
+	[QCOM_RPM_PM8038_SMPS2] =		{ 92, 33, 31, 2 },
+	[QCOM_RPM_PM8038_SMPS3] =		{ 94, 35, 32, 2 },
+	[QCOM_RPM_PM8038_SMPS4] =		{ 96, 37, 33, 2 },
+	[QCOM_RPM_PM8038_SMPS5] =		{ 98, 39, 34, 2 },
+	[QCOM_RPM_PM8038_SMPS6] =		{ 100, 41, 35, 2 },
+	[QCOM_RPM_PM8038_LDO1] =		{ 102, 43, 36, 2 },
+	[QCOM_RPM_PM8038_LDO2] =		{ 104, 45, 37, 2 },
+	[QCOM_RPM_PM8038_LDO3] =		{ 106, 47, 38, 2 },
+	[QCOM_RPM_PM8038_LDO4] =		{ 108, 49, 39, 2 },
+	[QCOM_RPM_PM8038_LDO5] =		{ 110, 51, 40, 2 },
+	[QCOM_RPM_PM8038_LDO6] =		{ 112, 53, 41, 2 },
+	[QCOM_RPM_PM8038_LDO7] =		{ 114, 55, 42, 2 },
+	[QCOM_RPM_PM8038_LDO8] =		{ 116, 57, 43, 2 },
+	[QCOM_RPM_PM8038_LDO9] =		{ 118, 59, 44, 2 },
+	[QCOM_RPM_PM8038_LDO10] =		{ 120, 61, 45, 2 },
+	[QCOM_RPM_PM8038_LDO11] =		{ 122, 63, 46, 2 },
+	[QCOM_RPM_PM8038_LDO12] =		{ 124, 65, 47, 2 },
+	[QCOM_RPM_PM8038_LDO13] =		{ 126, 67, 48, 2 },
+	[QCOM_RPM_PM8038_LDO14] =		{ 128, 69, 49, 2 },
+	[QCOM_RPM_PM8038_LDO15] =		{ 130, 71, 50, 2 },
+	[QCOM_RPM_PM8038_LDO16] =		{ 132, 73, 51, 2 },
+	[QCOM_RPM_PM8038_LDO17] =		{ 134, 75, 52, 2 },
+	[QCOM_RPM_PM8038_LDO18] =		{ 136, 77, 53, 2 },
+	[QCOM_RPM_PM8038_LDO19] =		{ 138, 79, 54, 2 },
+	[QCOM_RPM_PM8038_LDO20] =		{ 140, 81, 55, 2 },
+	[QCOM_RPM_PM8038_LDO21] =		{ 142, 83, 56, 2 },
+	[QCOM_RPM_PM8038_LDO22] =		{ 144, 85, 57, 2 },
+	[QCOM_RPM_PM8038_LDO23] =		{ 146, 87, 58, 2 },
+	[QCOM_RPM_PM8038_LDO24] =		{ 148, 89, 59, 2 },
+	[QCOM_RPM_PM8038_LDO25] =		{ 150, 91, 60, 2 },
+	[QCOM_RPM_PM8038_LDO26] =		{ 152, 93, 61, 2 },
+	[QCOM_RPM_PM8038_LDO27] =		{ 154, 95, 62, 2 },
+	[QCOM_RPM_PM8038_CLK1] =		{ 156, 97, 63, 2 },
+	[QCOM_RPM_PM8038_CLK2] =		{ 158, 99, 64, 2 },
+	[QCOM_RPM_PM8038_LVS1] =		{ 160, 101, 65, 1 },
+	[QCOM_RPM_PM8038_LVS2] =		{ 161, 102, 66, 1 },
+	// [QCOM_RPM_PM8038_NCP] =			{ 162, 103, 80, 2 },
+	[QCOM_RPM_CXO_BUFFERS] =		{ 164, 105, 81, 1 },
+	[QCOM_RPM_USB_OTG_SWITCH] =		{ 165, 106, 82, 1 },
+	[QCOM_RPM_HDMI_SWITCH] =		{ 166, 107, 83, 1 },
+	[QCOM_RPM_QDSS_CLK] =			{ 167, 108, 7, 1 },
+	[QCOM_RPM_VOLTAGE_CORNER] =		{ 168, 109, 87, 1 },
+
+	// [QCOM_RPM_DDR_DMM] =			{ ??, ??, 84, 2 },
+};
+
+static const struct qcom_rpm_data msm8930_template = {
+	.version = 3,
+	.resource_table = msm8930_rpm_resource_table,
+	.n_resources = ARRAY_SIZE(msm8930_rpm_resource_table),
+	.req_ctx_off = 3,
+	.req_sel_off = 11,
+	.ack_ctx_off = 15,
+	.ack_sel_off = 23,
+	.req_sel_size = 4,
+	.ack_sel_size = 7,
+};
+
 static const struct qcom_rpm_resource msm8960_rpm_resource_table[] = {
 	[QCOM_RPM_CXO_CLK] =			{ 25, 9, 5, 1 },
 	[QCOM_RPM_PXO_CLK] =			{ 26, 10, 6, 1 },
@@ -443,6 +529,7 @@ static const struct qcom_rpm_data mdm9615_template = {
 static const struct of_device_id qcom_rpm_of_match[] = {
 	{ .compatible = "qcom,rpm-apq8064", .data = &apq8064_template },
 	{ .compatible = "qcom,rpm-msm8660", .data = &msm8660_template },
+	{ .compatible = "qcom,rpm-msm8930", .data = &msm8930_template },
 	{ .compatible = "qcom,rpm-msm8960", .data = &msm8960_template },
 	{ .compatible = "qcom,rpm-ipq8064", .data = &ipq806x_template },
 	{ .compatible = "qcom,rpm-mdm9615", .data = &mdm9615_template },
diff --git a/drivers/power/supply/qcom_smbb.c b/drivers/power/supply/qcom_smbb.c
index 11de691b..c5742072 100644
--- a/drivers/power/supply/qcom_smbb.c
+++ b/drivers/power/supply/qcom_smbb.c
@@ -37,6 +37,7 @@
 #include <linux/extcon-provider.h>
 #include <linux/regulator/driver.h>
 
+#if 0
 #define SMBB_CHG_VMAX		0x040
 #define SMBB_CHG_VSAFE		0x041
 #define SMBB_CHG_CFG		0x043
@@ -88,6 +89,8 @@
 #define SMBB_MISC_BOOT_DONE	0x642
 #define BOOT_DONE		BIT(7)
 
+#endif
+
 #define STATUS_USBIN_VALID	BIT(0) /* USB connection is valid */
 #define STATUS_DCIN_VALID	BIT(1) /* DC connection is valid */
 #define STATUS_BAT_HOT		BIT(2) /* Battery temp 1=Hot, 0=Cold */
@@ -98,9 +101,76 @@
 #define STATUS_CHG_FAST		BIT(7) /* Fast charging */
 #define STATUS_CHG_GONE		BIT(8) /* No charger is connected */
 
+#define CHG_BUCK_CLOCK_CTRL	0x14
+#define CHG_BUCK_CLOCK_CTRL_8038	0xD
+
+#define PBL_ACCESS1		0x04
+#define PBL_ACCESS2		0x05
+#define SYS_CONFIG_1		0x06
+#define SYS_CONFIG_2		0x07
+#define CHG_CNTRL		0x204
+#define CHG_IBAT_MAX		0x205
+#define CHG_TEST		0x206
+#define CHG_BUCK_CTRL_TEST1	0x207
+#define CHG_BUCK_CTRL_TEST2	0x208
+#define CHG_BUCK_CTRL_TEST3	0x209
+#define COMPARATOR_OVERRIDE	0x20A
+#define PSI_TXRX_SAMPLE_DATA_0	0x20B
+#define PSI_TXRX_SAMPLE_DATA_1	0x20C
+#define PSI_TXRX_SAMPLE_DATA_2	0x20D
+#define PSI_TXRX_SAMPLE_DATA_3	0x20E
+#define PSI_CONFIG_STATUS	0x20F
+#define CHG_IBAT_SAFE		0x210
+#define CHG_ITRICKLE		0x211
+#define CHG_CNTRL_2		0x212
+#define CHG_VBAT_DET		0x213
+#define CHG_VTRICKLE		0x214
+#define CHG_ITERM		0x215
+#define CHG_CNTRL_3		0x216
+#define CHG_VIN_MIN		0x217
+#define CHG_TWDOG		0x218
+#define CHG_TTRKL_MAX		0x219
+#define CHG_TEMP_THRESH		0x21A
+#define CHG_TCHG_MAX		0x21B
+#define USB_OVP_CONTROL		0x21C
+#define DC_OVP_CONTROL		0x21D
+#define USB_OVP_TEST		0x21E
+#define DC_OVP_TEST		0x21F
+#define CHG_VDD_MAX		0x220
+#define CHG_VDD_SAFE		0x221
+#define CHG_VBAT_BOOT_THRESH	0x222
+#define USB_OVP_TRIM		0x355
+#define BUCK_CONTROL_TRIM1	0x356
+#define BUCK_CONTROL_TRIM2	0x357
+#define BUCK_CONTROL_TRIM3	0x358
+#define BUCK_CONTROL_TRIM4	0x359
+#define CHG_DEFAULTS_TRIM	0x35A
+#define CHG_ITRIM		0x35B
+#define CHG_TTRIM		0x35C
+#define CHG_COMP_OVR		0x20A
+#define IUSB_FINE_RES		0x2B6
+#define OVP_USB_UVD		0x2B7
+#define PM8921_USB_TRIM_SEL	0x339
+
+#define ENUM_TIMER_STOP_BIT	BIT(1)
+#define BOOT_DONE_BIT		BIT(6)
+#define CHG_BATFET_ON_BIT	BIT(3)
+#define CHG_VCP_EN		BIT(0)
+#define CHG_BAT_TEMP_DIS_BIT	BIT(2)
+
+#define CHG_EN_BIT	BIT(7)
+
+#define PM8921_CHG_V_MASK		0x7F
+#define PM8921_CHG_I_MASK		0x3F
+#define PM8921_CHG_ITERM_MASK	0xF
+
+#define MV(x) (((x) - 3240) / 20)
+#define MA(x) (((x) - 225) / 50)
+
 enum smbb_attr {
 	ATTR_BAT_ISAFE,
 	ATTR_BAT_IMAX,
+#if 0
 	ATTR_USBIN_IMAX,
 	ATTR_DCIN_IMAX,
 	ATTR_BAT_VSAFE,
@@ -108,17 +178,18 @@ enum smbb_attr {
 	ATTR_BAT_VMIN,
 	ATTR_CHG_VDET,
 	ATTR_VIN_MIN,
+#endif
 	_ATTR_CNT,
 };
 
 struct smbb_charger {
-	unsigned int revision;
+	// unsigned int revision;
 	unsigned int addr;
 	struct device *dev;
 	struct extcon_dev *edev;
 
 	bool dc_disabled;
-	bool jeita_ext_temp;
+	// bool jeita_ext_temp;
 	unsigned long status;
 	struct mutex statlock;
 
@@ -169,7 +240,7 @@ static int smbb_imax_fn(unsigned int index)
 
 static int smbb_bat_imax_fn(unsigned int index)
 {
-	return index * 50000;
+	return 225000 + index * 50000;
 }
 
 static unsigned int smbb_hw_lookup(unsigned int val, int (*fn)(unsigned int))
@@ -194,20 +265,21 @@ static const struct smbb_charger_attr {
 } smbb_charger_attrs[] = {
 	[ATTR_BAT_ISAFE] = {
 		.name = "qcom,fast-charge-safe-current",
-		.reg = SMBB_CHG_ISAFE,
-		.max = 3000000,
-		.min = 200000,
+		.reg = CHG_IBAT_SAFE,
+		.max = 3375000,
+		.min = 225000,
 		.hw_fn = smbb_bat_imax_fn,
 		.fail_ok = 1,
 	},
 	[ATTR_BAT_IMAX] = {
 		.name = "qcom,fast-charge-current-limit",
-		.reg = SMBB_CHG_IMAX,
-		.safe_reg = SMBB_CHG_ISAFE,
-		.max = 3000000,
-		.min = 200000,
+		.reg = CHG_IBAT_MAX,
+		.safe_reg = CHG_IBAT_SAFE,
+		.max = 3025000,
+		.min = 325000,
 		.hw_fn = smbb_bat_imax_fn,
 	},
+#if 0
 	[ATTR_DCIN_IMAX] = {
 		.name = "qcom,dc-current-limit",
 		.reg = SMBB_DC_IMAX,
@@ -259,6 +331,7 @@ static const struct smbb_charger_attr {
 		.min = 100000,
 		.hw_fn = smbb_imax_fn,
 	},
+#endif
 };
 
 static int smbb_charger_attr_write(struct smbb_charger *chg,
@@ -379,6 +452,8 @@ static void smbb_set_line_flag(struct smbb_charger *chg, int irq, int flag)
 	dev_dbg(chg->dev, "status = %03lx\n", chg->status);
 }
 
+#if 0
+
 static irqreturn_t smbb_usb_valid_handler(int irq, void *_data)
 {
 	struct smbb_charger *chg = _data;
@@ -479,10 +554,13 @@ static irqreturn_t smbb_chg_trkl_handler(int irq, void *_data)
 	return IRQ_HANDLED;
 }
 
+#endif
+
 static const struct smbb_irq {
 	const char *name;
 	irqreturn_t (*handler)(int, void *);
 } smbb_charger_irqs[] = {
+#if 0
 	{ "chg-done", smbb_chg_done_handler },
 	{ "chg-fast", smbb_chg_fast_handler },
 	{ "chg-trkl", smbb_chg_trkl_handler },
@@ -491,6 +569,7 @@ static const struct smbb_irq {
 	{ "chg-gone", smbb_chg_gone_handler },
 	{ "usb-valid", smbb_usb_valid_handler },
 	{ "dc-valid", smbb_dc_valid_handler },
+#endif
 };
 
 static int smbb_usbin_get_property(struct power_supply *psy,
@@ -508,7 +587,7 @@ static int smbb_usbin_get_property(struct power_supply *psy,
 		mutex_unlock(&chg->statlock);
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
-		val->intval = chg->attr[ATTR_USBIN_IMAX];
+		val->intval = 0; //chg->attr[ATTR_USBIN_IMAX];
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
 		val->intval = 2500000;
@@ -530,8 +609,7 @@ static int smbb_usbin_set_property(struct power_supply *psy,
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
-		rc = smbb_charger_attr_write(chg, ATTR_USBIN_IMAX,
-				val->intval);
+		rc = 0; //smbb_charger_attr_write(chg, ATTR_USBIN_IMAX, val->intval);
 		break;
 	default:
 		rc = -EINVAL;
@@ -551,12 +629,11 @@ static int smbb_dcin_get_property(struct power_supply *psy,
 	switch (psp) {
 	case POWER_SUPPLY_PROP_ONLINE:
 		mutex_lock(&chg->statlock);
-		val->intval = !(chg->status & STATUS_CHG_GONE) &&
-				(chg->status & STATUS_DCIN_VALID);
+		val->intval = 0; // !(chg->status & STATUS_CHG_GONE) && (chg->status & STATUS_DCIN_VALID);
 		mutex_unlock(&chg->statlock);
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
-		val->intval = chg->attr[ATTR_DCIN_IMAX];
+		val->intval = 0; //chg->attr[ATTR_DCIN_IMAX];
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
 		val->intval = 2500000;
@@ -578,8 +655,7 @@ static int smbb_dcin_set_property(struct power_supply *psy,
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
-		rc = smbb_charger_attr_write(chg, ATTR_DCIN_IMAX,
-				val->intval);
+		rc = 0; //smbb_charger_attr_write(chg, ATTR_DCIN_IMAX, val->intval);
 		break;
 	default:
 		rc = -EINVAL;
@@ -607,6 +683,7 @@ static int smbb_battery_get_property(struct power_supply *psy,
 	status = chg->status;
 	mutex_unlock(&chg->statlock);
 
+#if 0
 	switch (psp) {
 	case POWER_SUPPLY_PROP_STATUS:
 		if (status & STATUS_CHG_GONE)
@@ -661,6 +738,9 @@ static int smbb_battery_get_property(struct power_supply *psy,
 		rc = -EINVAL;
 		break;
 	}
+#endif
+	val->intval = 0;
+	return 0;
 
 	return rc;
 }
@@ -674,10 +754,10 @@ static int smbb_battery_set_property(struct power_supply *psy,
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_CURRENT_MAX:
-		rc = smbb_charger_attr_write(chg, ATTR_BAT_IMAX, val->intval);
+		rc = 0; // smbb_charger_attr_write(chg, ATTR_BAT_IMAX, val->intval);
 		break;
 	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
-		rc = smbb_charger_attr_write(chg, ATTR_BAT_VMAX, val->intval);
+		rc = 0; // smbb_charger_attr_write(chg, ATTR_BAT_VMAX, val->intval);
 		break;
 	default:
 		rc = -EINVAL;
@@ -722,9 +802,18 @@ static const struct reg_off_mask_default {
 	unsigned int value;
 	unsigned int rev_mask;
 } smbb_charger_setup[] = {
-	/* The bootloader is supposed to set this... make sure anyway. */
-	{ SMBB_MISC_BOOT_DONE, BOOT_DONE, BOOT_DONE },
-
+	{ SYS_CONFIG_2, BOOT_DONE_BIT, BOOT_DONE_BIT },
+	{ CHG_VDD_SAFE, PM8921_CHG_V_MASK, MV(4200) }, // 4500
+	{ CHG_VBAT_DET, PM8921_CHG_V_MASK, MV(4140) },
+	{ CHG_VDD_MAX, PM8921_CHG_V_MASK, MV(4200) }, // increments?
+	{ CHG_IBAT_SAFE, PM8921_CHG_I_MASK, MA(1500) },
+	{ CHG_IBAT_MAX, PM8921_CHG_I_MASK, MA(1100) },
+	{ CHG_VDD_MAX, PM8921_CHG_ITERM_MASK, (100 - 50) / 10 },
+
+	{PBL_ACCESS2, ENUM_TIMER_STOP_BIT, ENUM_TIMER_STOP_BIT},
+	{CHG_CNTRL_3, CHG_EN_BIT, CHG_EN_BIT},
+
+#if 0
 	/* Disable software timer */
 	{ SMBB_CHG_TCHG_MAX_EN, TCHG_MAX_EN, 0 },
 
@@ -759,6 +848,7 @@ static const struct reg_off_mask_default {
 
 	/* Enable charging */
 	{ SMBB_CHG_CTRL, CTRL_EN, CTRL_EN },
+#endif
 };
 
 static char *smbb_bif[] = { "smbb-bif" };
@@ -798,8 +888,8 @@ static int smbb_chg_otg_enable(struct regulator_dev *rdev)
 	struct smbb_charger *chg = rdev_get_drvdata(rdev);
 	int rc;
 
-	rc = regmap_update_bits(chg->regmap, chg->addr + SMBB_USB_OTG_CTL,
-				OTG_CTL_EN, OTG_CTL_EN);
+	rc = 0; /* regmap_update_bits(chg->regmap, chg->addr + SMBB_USB_OTG_CTL,
+				OTG_CTL_EN, OTG_CTL_EN); */
 	if (rc)
 		dev_err(chg->dev, "failed to update OTG_CTL\n");
 	return rc;
@@ -810,8 +900,8 @@ static int smbb_chg_otg_disable(struct regulator_dev *rdev)
 	struct smbb_charger *chg = rdev_get_drvdata(rdev);
 	int rc;
 
-	rc = regmap_update_bits(chg->regmap, chg->addr + SMBB_USB_OTG_CTL,
-				OTG_CTL_EN, 0);
+	rc = 0; /* regmap_update_bits(chg->regmap, chg->addr + SMBB_USB_OTG_CTL,
+				OTG_CTL_EN, 0); */
 	if (rc)
 		dev_err(chg->dev, "failed to update OTG_CTL\n");
 	return rc;
@@ -823,11 +913,11 @@ static int smbb_chg_otg_is_enabled(struct regulator_dev *rdev)
 	unsigned int value = 0;
 	int rc;
 
-	rc = regmap_read(chg->regmap, chg->addr + SMBB_USB_OTG_CTL, &value);
+	rc = 0; // regmap_read(chg->regmap, chg->addr + SMBB_USB_OTG_CTL, &value);
 	if (rc)
 		dev_err(chg->dev, "failed to read OTG_CTL\n");
 
-	return !!(value & OTG_CTL_EN);
+	return 0; // !!(value & OTG_CTL_EN);
 }
 
 static const struct regulator_ops smbb_chg_otg_ops = {
@@ -864,6 +954,7 @@ static int smbb_charger_probe(struct platform_device *pdev)
 		return rc;
 	}
 
+#if 0
 	rc = regmap_read(chg->regmap, chg->addr + SMBB_MISC_REV2, &chg->revision);
 	if (rc) {
 		dev_err(&pdev->dev, "unable to read revision\n");
@@ -876,6 +967,7 @@ static int smbb_charger_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 	dev_info(&pdev->dev, "Initializing SMBB rev %u", chg->revision);
+#endif
 
 	chg->dc_disabled = of_property_read_bool(pdev->dev.of_node, "qcom,disable-dc");
 
@@ -975,6 +1067,7 @@ static int smbb_charger_probe(struct platform_device *pdev)
 	if (IS_ERR(chg->otg_reg))
 		return PTR_ERR(chg->otg_reg);
 
+#if 0
 	chg->jeita_ext_temp = of_property_read_bool(pdev->dev.of_node,
 			"qcom,jeita-extended-temp-range");
 
@@ -990,12 +1083,15 @@ static int smbb_charger_probe(struct platform_device *pdev)
 			chg->jeita_ext_temp ? "JEITA extended" : "normal");
 		return rc;
 	}
+#endif
 
 	for (i = 0; i < ARRAY_SIZE(smbb_charger_setup); ++i) {
 		const struct reg_off_mask_default *r = &smbb_charger_setup[i];
 
+#if 0
 		if (r->rev_mask & BIT(chg->revision))
 			continue;
+#endif
 
 		rc = regmap_update_bits(chg->regmap, chg->addr + r->offset,
 				r->mask, r->value);
@@ -1017,7 +1113,7 @@ static int smbb_charger_remove(struct platform_device *pdev)
 
 	chg = platform_get_drvdata(pdev);
 
-	regmap_update_bits(chg->regmap, chg->addr + SMBB_CHG_CTRL, CTRL_EN, 0);
+	// regmap_update_bits(chg->regmap, chg->addr + CHG_CTRL, CTRL_EN, 0);
 
 	return 0;
 }
diff --git a/drivers/regulator/qcom_rpm-regulator.c b/drivers/regulator/qcom_rpm-regulator.c
index 88dc0b0f..0bec7167 100644
--- a/drivers/regulator/qcom_rpm-regulator.c
+++ b/drivers/regulator/qcom_rpm-regulator.c
@@ -153,6 +153,11 @@ static const struct rpm_reg_parts rpm8960_ncp_parts = {
 	.freq           = { 0, 0x3E000000, 25 },
 };
 
+static const struct rpm_reg_parts rpm8930_corner_parts = {
+	.request_len    = 1,
+	.uV             = { 0, 0x00000003,  0 },
+};
+
 /*
  * Physically available PMIC regulator voltage ranges
  */
@@ -194,6 +199,10 @@ static const struct regulator_linear_range ncp_ranges[] = {
 	REGULATOR_LINEAR_RANGE(1500000,   0,  31, 50000),
 };
 
+static const struct regulator_linear_range corner_ranges[] = {
+	REGULATOR_LINEAR_RANGE(0, 0, 3, 1),
+};
+
 static int rpm_reg_write(struct qcom_rpm_reg *vreg,
 			 const struct request_member *req,
 			 const int value)
@@ -447,6 +456,61 @@ static struct regulator_ops switch_ops = {
 	.is_enabled = rpm_reg_is_enabled,
 };
 
+static int rpm_reg_set_corner_sel(struct regulator_dev *rdev,
+			      unsigned selector)
+{
+	struct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);
+	const struct rpm_reg_parts *parts = vreg->parts;
+	const struct request_member *req = &parts->uV;
+	int ret = 0;
+	int uV;
+
+	if (req->mask == 0)
+		return -EINVAL;
+
+	uV = regulator_list_voltage_linear_range(rdev, selector);
+	if (uV < 0)
+		return uV;
+
+	printk("SETTING UV=%u %u\n", uV, vreg->is_enabled);
+
+	mutex_lock(&vreg->lock);
+	//if (vreg->is_enabled)
+		ret = rpm_reg_write(vreg, req, uV);
+
+	if (!ret)
+		vreg->uV = uV;
+	mutex_unlock(&vreg->lock);
+
+	return ret;
+}
+
+static int rpm_reg_corner_enable(struct regulator_dev *rdev)
+{
+	return 0;
+}
+
+static int rpm_reg_corner_disable(struct regulator_dev *rdev)
+{
+	return 0;
+}
+
+static int rpm_corner_is_enabled(struct regulator_dev *rdev)
+{
+	return 1;
+}
+
+static struct regulator_ops corner_ops = {
+	.list_voltage = regulator_list_voltage_linear_range,
+
+	.set_voltage_sel = rpm_reg_set_corner_sel,
+	.get_voltage = rpm_reg_get_voltage,
+
+	.enable = rpm_reg_corner_enable,
+	.disable = rpm_reg_corner_disable,
+	.is_enabled = rpm_corner_is_enabled,
+};
+
 /*
  * PM8018 regulators
  */
@@ -635,6 +699,14 @@ static const struct qcom_rpm_reg pm8921_switch = {
 	.parts = &rpm8960_switch_parts,
 };
 
+static const struct qcom_rpm_reg pm8038_corner = {
+	.desc.linear_ranges = corner_ranges,
+	.desc.n_linear_ranges = ARRAY_SIZE(corner_ranges),
+	.desc.n_voltages = 4,
+	.desc.ops = &corner_ops,
+	.parts = &rpm8930_corner_parts,
+};
+
 static const struct qcom_rpm_reg smb208_smps = {
 	.desc.linear_ranges = smb208_ranges,
 	.desc.n_linear_ranges = ARRAY_SIZE(smb208_ranges),
@@ -819,6 +891,54 @@ static const struct rpm_regulator_data rpm_pm8018_regulators[] = {
 	{ }
 };
 
+static const struct rpm_regulator_data rpm_pm8038_regulators[] = {
+	{ "l1",   QCOM_RPM_PM8038_LDO1,   &pm8921_nldo1200, "vdd_l1" },
+	{ "l2",   QCOM_RPM_PM8038_LDO2,   &pm8921_nldo, "vdd_l2_l20" },
+	{ "l3",   QCOM_RPM_PM8038_LDO3,   &pm8921_pldo, "vdd_l3_l9_l15_l17_l22" },
+	{ "l4",   QCOM_RPM_PM8038_LDO4,   &pm8921_pldo, "vdd_l4_l13_l14_l18_l25" },
+	{ "l5",   QCOM_RPM_PM8038_LDO5,   &pm8921_pldo, "vdd_l5_l6" },
+	{ "l6",   QCOM_RPM_PM8038_LDO6,   &pm8921_pldo, "vdd_l5_l6" },
+	{ "l7",   QCOM_RPM_PM8038_LDO7,   &pm8921_pldo, "vdd_l7_l11_l21_l23" },
+	{ "l8",   QCOM_RPM_PM8038_LDO8,   &pm8921_pldo, "vdd_l8" },
+	{ "l9",   QCOM_RPM_PM8038_LDO9,   &pm8921_pldo, "vdd_l3_l9_l15_l17_l22" },
+	{ "l10",  QCOM_RPM_PM8038_LDO10,  &pm8921_pldo, "vdd_l10" },
+	{ "l11",  QCOM_RPM_PM8038_LDO11,  &pm8921_pldo, "vdd_l7_l11_l21_l23" },
+	{ "l12",  QCOM_RPM_PM8038_LDO12,  &pm8921_nldo, "vdd_l12_l24_l26" },
+	// { "l13",  QCOM_RPM_PM8038_LDO13,  &pm8921_lldo, "vdd_l4_l13_l14_l18_l25" },
+	{ "l14",  QCOM_RPM_PM8038_LDO14,  &pm8921_pldo, "vdd_l4_l13_l14_l18_l25" },
+	{ "l15",  QCOM_RPM_PM8038_LDO15,  &pm8921_pldo, "vdd_l3_l9_l15_l17_l22" },
+	{ "l16",  QCOM_RPM_PM8038_LDO16,  &pm8921_nldo1200, "vdd_l16_l19" },
+	{ "l17",  QCOM_RPM_PM8038_LDO17,  &pm8921_pldo, "vdd_l3_l9_l15_l17_l22" },
+	{ "l18",  QCOM_RPM_PM8038_LDO18,  &pm8921_pldo, "vdd_l4_l13_l14_l18_l25" },
+	{ "l19",  QCOM_RPM_PM8038_LDO19,  &pm8921_nldo1200, "vdd_l16_l19" },
+	{ "l20",  QCOM_RPM_PM8038_LDO20,  &pm8921_nldo1200, "vdd_l2_l20" },
+	{ "l21",  QCOM_RPM_PM8038_LDO21,  &pm8921_pldo, "vdd_l7_l11_l21_l23" },
+	{ "l22",  QCOM_RPM_PM8038_LDO22,  &pm8921_pldo, "vdd_l3_l9_l15_l17_l22" },
+	{ "l23",  QCOM_RPM_PM8038_LDO23,  &pm8921_pldo, "vdd_l7_l11_l21_l23" },
+	{ "l24",  QCOM_RPM_PM8038_LDO24,  &pm8921_nldo1200, "vdd_l12_l24_l26" },
+	// { "l25",  QCOM_RPM_PM8038_LDO25,  &pm8921_lldo, "vdd_l4_l13_l14_l18_l25" },
+	{ "l26",  QCOM_RPM_PM8038_LDO26,  &pm8921_nldo, "vdd_l12_l24_l26" },
+	{ "l27",  QCOM_RPM_PM8038_LDO27,  &pm8921_nldo1200, "vdd_l27" },
+
+	{ "s1",   QCOM_RPM_PM8038_SMPS1,  &pm8921_smps, "vdd_s1" },
+	{ "s2",   QCOM_RPM_PM8038_SMPS2,  &pm8921_smps, "vdd_s2" },
+	{ "s3",   QCOM_RPM_PM8038_SMPS3,  &pm8921_smps, "vdd_s3" },
+	{ "s4",   QCOM_RPM_PM8038_SMPS4,  &pm8921_smps, "vdd_s4" },
+	{ "s5",   QCOM_RPM_PM8038_SMPS5,  &pm8921_ftsmps, "vdd_s5" },
+	{ "s6",   QCOM_RPM_PM8038_SMPS6,  &pm8921_ftsmps, "vdd_s6" },
+
+	{ "lvs1", QCOM_RPM_PM8038_LVS1, &pm8921_switch, "vin_lvs" },
+	{ "lvs2", QCOM_RPM_PM8038_LVS2, &pm8921_switch, "vin_lvs" },
+
+	{ "corner", QCOM_RPM_VOLTAGE_CORNER, &pm8038_corner, "vdd_corner"},
+
+	// VDD_DIG_CORNER
+	//{ "ncp",  QCOM_RPM_PM8058_NCP, &pm8058_ncp, "vdd_ncp" },
+
+	{ "usb-switch", QCOM_RPM_USB_OTG_SWITCH, &pm8921_switch, "vin_5vs" },
+	{ }
+};
+
 static const struct rpm_regulator_data rpm_pm8058_regulators[] = {
 	{ "l0",   QCOM_RPM_PM8058_LDO0,   &pm8058_nldo, "vdd_l0_l1_lvs"	},
 	{ "l1",   QCOM_RPM_PM8058_LDO1,   &pm8058_nldo, "vdd_l0_l1_lvs" },
@@ -934,8 +1054,8 @@ static const struct rpm_regulator_data rpm_pm8921_regulators[] = {
 };
 
 static const struct of_device_id rpm_of_match[] = {
-	{ .compatible = "qcom,rpm-pm8018-regulators",
-		.data = &rpm_pm8018_regulators },
+	{ .compatible = "qcom,rpm-pm8018-regulators", .data = &rpm_pm8018_regulators },
+	{ .compatible = "qcom,rpm-pm8038-regulators", .data = &rpm_pm8038_regulators },
 	{ .compatible = "qcom,rpm-pm8058-regulators", .data = &rpm_pm8058_regulators },
 	{ .compatible = "qcom,rpm-pm8901-regulators", .data = &rpm_pm8901_regulators },
 	{ .compatible = "qcom,rpm-pm8921-regulators", .data = &rpm_pm8921_regulators },
diff --git a/drivers/usb/chipidea/otg.c b/drivers/usb/chipidea/otg.c
index db4ceffc..b938b0a8 100644
--- a/drivers/usb/chipidea/otg.c
+++ b/drivers/usb/chipidea/otg.c
@@ -123,7 +123,7 @@ enum ci_role ci_otg_role(struct ci_hdrc *ci)
 		? CI_ROLE_GADGET
 		: CI_ROLE_HOST;
 
-	return role;
+	return CI_ROLE_GADGET; //role;
 }
 
 void ci_handle_vbus_change(struct ci_hdrc *ci)
@@ -167,7 +167,7 @@ static void ci_handle_id_switch(struct ci_hdrc *ci)
 	enum ci_role role = ci_otg_role(ci);
 
 	if (role != ci->role) {
-		dev_dbg(ci->dev, "switching from %s to %s\n",
+		dev_warn(ci->dev, "switching from %s to %s\n",
 			ci_role(ci)->name, ci->roles[role]->name);
 
 		ci_role_stop(ci);
diff --git a/drivers/video/backlight/pm8941-wled.c b/drivers/video/backlight/pm8941-wled.c
index 0b6d2195..f8efc52b 100644
--- a/drivers/video/backlight/pm8941-wled.c
+++ b/drivers/video/backlight/pm8941-wled.c
@@ -20,14 +20,14 @@
 /* From DT binding */
 #define PM8941_WLED_DEFAULT_BRIGHTNESS		2048
 
-#define PM8941_WLED_REG_VAL_BASE		0x40
+#define PM8941_WLED_REG_VAL_BASE		0x04 //0x40
 #define  PM8941_WLED_REG_VAL_MAX		0xFFF
 
-#define PM8941_WLED_REG_MOD_EN			0x46
-#define  PM8941_WLED_REG_MOD_EN_BIT		BIT(7)
-#define  PM8941_WLED_REG_MOD_EN_MASK		BIT(7)
+#define PM8941_WLED_REG_MOD_EN			0x0	  //0x46
+#define  PM8941_WLED_REG_MOD_EN_BIT		0x7f  //BIT(7)
+#define  PM8941_WLED_REG_MOD_EN_MASK	0x7f  //BIT(7)
 
-#define PM8941_WLED_REG_SYNC			0x47
+#define PM8941_WLED_REG_SYNC			0x0a //0x47
 #define  PM8941_WLED_REG_SYNC_MASK		0x07
 #define  PM8941_WLED_REG_SYNC_LED1		BIT(0)
 #define  PM8941_WLED_REG_SYNC_LED2		BIT(1)
@@ -35,21 +35,21 @@
 #define  PM8941_WLED_REG_SYNC_ALL		0x07
 #define  PM8941_WLED_REG_SYNC_CLEAR		0x00
 
-#define PM8941_WLED_REG_FREQ			0x4c
-#define  PM8941_WLED_REG_FREQ_MASK		0x0f
+//#define PM8941_WLED_REG_FREQ			0x4c
+//#define  PM8941_WLED_REG_FREQ_MASK		0x0f
 
-#define PM8941_WLED_REG_OVP			0x4d
-#define  PM8941_WLED_REG_OVP_MASK		0x03
+#define PM8941_WLED_REG_OVP				0x0c //0x4d
+#define  PM8941_WLED_REG_OVP_MASK		0x30 //0x03
 
-#define PM8941_WLED_REG_BOOST			0x4e
-#define  PM8941_WLED_REG_BOOST_MASK		0x07
+#define PM8941_WLED_REG_BOOST			0x0d //0x4e
+#define  PM8941_WLED_REG_BOOST_MASK		0xe0 //0x07
 
-#define PM8941_WLED_REG_SINK			0x4f
-#define  PM8941_WLED_REG_SINK_MASK		0xe0
-#define  PM8941_WLED_REG_SINK_SHFT		0x05
+//#define PM8941_WLED_REG_SINK			0x4f
+//#define  PM8941_WLED_REG_SINK_MASK		0xe0
+//#define  PM8941_WLED_REG_SINK_SHFT		0x05
 
 /* Per-'string' registers below */
-#define PM8941_WLED_REG_STR_OFFSET		0x10
+/* #define PM8941_WLED_REG_STR_OFFSET		0x10
 
 #define PM8941_WLED_REG_STR_MOD_EN_BASE		0x60
 #define  PM8941_WLED_REG_STR_MOD_MASK		BIT(7)
@@ -65,7 +65,7 @@
 
 #define PM8941_WLED_REG_STR_CABC_BASE		0x66
 #define  PM8941_WLED_REG_STR_CABC_MASK		BIT(7)
-#define  PM8941_WLED_REG_STR_CABC_EN		BIT(7)
+#define  PM8941_WLED_REG_STR_CABC_EN		BIT(7) */
 
 struct pm8941_wled_config {
 	u32 i_boost_limit;
@@ -109,7 +109,7 @@ static int pm8941_wled_update_status(struct backlight_device *bl)
 		return rc;
 
 	for (i = 0; i < wled->cfg.num_strings; ++i) {
-		u8 v[2] = { val & 0xff, (val >> 8) & 0xf };
+		u8 v[2] = { 0x70 | (val >> 8) & 0xf, val & 0xff };
 
 		rc = regmap_bulk_write(wled->regmap,
 				wled->addr + PM8941_WLED_REG_VAL_BASE + 2 * i,
@@ -134,26 +134,27 @@ static int pm8941_wled_setup(struct pm8941_wled *wled)
 {
 	int rc;
 	int i;
+	u16 val = 2048;
 
 	rc = regmap_update_bits(wled->regmap,
 			wled->addr + PM8941_WLED_REG_OVP,
-			PM8941_WLED_REG_OVP_MASK, wled->cfg.ovp);
+			PM8941_WLED_REG_OVP_MASK, wled->cfg.ovp << 4);
 	if (rc)
 		return rc;
 
 	rc = regmap_update_bits(wled->regmap,
 			wled->addr + PM8941_WLED_REG_BOOST,
-			PM8941_WLED_REG_BOOST_MASK, wled->cfg.i_boost_limit);
+			PM8941_WLED_REG_BOOST_MASK | 0x1c, wled->cfg.i_boost_limit << 5 | 4);
 	if (rc)
 		return rc;
 
-	rc = regmap_update_bits(wled->regmap,
+	/* rc = regmap_update_bits(wled->regmap,
 			wled->addr + PM8941_WLED_REG_FREQ,
 			PM8941_WLED_REG_FREQ_MASK, wled->cfg.switch_freq);
 	if (rc)
-		return rc;
+		return rc; */
 
-	if (wled->cfg.cs_out_en) {
+	/* if (wled->cfg.cs_out_en) {
 		u8 all = (BIT(wled->cfg.num_strings) - 1)
 				<< PM8941_WLED_REG_SINK_SHFT;
 
@@ -162,10 +163,10 @@ static int pm8941_wled_setup(struct pm8941_wled *wled)
 				PM8941_WLED_REG_SINK_MASK, all);
 		if (rc)
 			return rc;
-	}
+	} */
 
 	for (i = 0; i < wled->cfg.num_strings; ++i) {
-		u16 addr = wled->addr + PM8941_WLED_REG_STR_OFFSET * i;
+		/*u16 addr = wled->addr + PM8941_WLED_REG_STR_OFFSET * i;
 
 		rc = regmap_update_bits(wled->regmap,
 				addr + PM8941_WLED_REG_STR_MOD_EN_BASE,
@@ -195,10 +196,42 @@ static int pm8941_wled_setup(struct pm8941_wled *wled)
 				PM8941_WLED_REG_STR_CABC_MASK,
 				wled->cfg.cabc_en ?
 					PM8941_WLED_REG_STR_CABC_EN : 0);
+		if (rc)
+			return rc; */
+	}
+
+	rc = regmap_update_bits(wled->regmap,
+			wled->addr + PM8941_WLED_REG_MOD_EN,
+			PM8941_WLED_REG_MOD_EN_MASK, PM8941_WLED_REG_MOD_EN_BIT);
+	if (rc)
+		return rc;
+
+	rc = regmap_update_bits(wled->regmap,
+			wled->addr + 14,
+			0xff, 0x3f);
+	if (rc)
+		return rc;
+
+	for (i = 0; i < wled->cfg.num_strings; ++i) {
+		u8 v[2] = { 0x70 | (val >> 8) & 0xf, val & 0xff };
+
+		rc = regmap_bulk_write(wled->regmap,
+				wled->addr + PM8941_WLED_REG_VAL_BASE + 2 * i,
+				v, 2);
 		if (rc)
 			return rc;
 	}
 
+	rc = regmap_update_bits(wled->regmap,
+			wled->addr + PM8941_WLED_REG_SYNC,
+			PM8941_WLED_REG_SYNC_MASK, PM8941_WLED_REG_SYNC_ALL);
+	if (rc)
+		return rc;
+
+	rc = regmap_update_bits(wled->regmap,
+			wled->addr + PM8941_WLED_REG_SYNC,
+			PM8941_WLED_REG_SYNC_MASK, PM8941_WLED_REG_SYNC_CLEAR);
+
 	return 0;
 }
 
diff --git a/include/dt-bindings/clock/qcom,gcc-msm8960.h b/include/dt-bindings/clock/qcom,gcc-msm8960.h
index 7d20eedf..e02742fc 100644
--- a/include/dt-bindings/clock/qcom,gcc-msm8960.h
+++ b/include/dt-bindings/clock/qcom,gcc-msm8960.h
@@ -319,5 +319,7 @@
 #define CE3_SRC					303
 #define CE3_CORE_CLK				304
 #define CE3_H_CLK				305
+#define PLL16					306
+#define PLL17					307
 
 #endif
diff --git a/include/dt-bindings/mfd/qcom-rpm.h b/include/dt-bindings/mfd/qcom-rpm.h
index c9204c4d..ec6a3932 100644
--- a/include/dt-bindings/mfd/qcom-rpm.h
+++ b/include/dt-bindings/mfd/qcom-rpm.h
@@ -171,6 +171,44 @@
 #define QCOM_RPM_PM8018_NCP			160
 #define QCOM_RPM_VOLTAGE_CORNER			161
 
+#define QCOM_RPM_PM8038_LDO1			162
+#define QCOM_RPM_PM8038_LDO2			163
+#define QCOM_RPM_PM8038_LDO3			164
+#define QCOM_RPM_PM8038_LDO4			165
+#define QCOM_RPM_PM8038_LDO5			166
+#define QCOM_RPM_PM8038_LDO6			167
+#define QCOM_RPM_PM8038_LDO7			168
+#define QCOM_RPM_PM8038_LDO8			169
+#define QCOM_RPM_PM8038_LDO9			170
+#define QCOM_RPM_PM8038_LDO10			171
+#define QCOM_RPM_PM8038_LDO11			172
+#define QCOM_RPM_PM8038_LDO12			173
+#define QCOM_RPM_PM8038_LDO13			174
+#define QCOM_RPM_PM8038_LDO14			175
+#define QCOM_RPM_PM8038_LDO15			176
+#define QCOM_RPM_PM8038_LDO16			177
+#define QCOM_RPM_PM8038_LDO17			178
+#define QCOM_RPM_PM8038_LDO18			179
+#define QCOM_RPM_PM8038_LDO19			180
+#define QCOM_RPM_PM8038_LDO20			181
+#define QCOM_RPM_PM8038_LDO21			182
+#define QCOM_RPM_PM8038_LDO22			183
+#define QCOM_RPM_PM8038_LDO23			184
+#define QCOM_RPM_PM8038_LDO24			185
+#define QCOM_RPM_PM8038_LDO25			186
+#define QCOM_RPM_PM8038_LDO26			187
+#define QCOM_RPM_PM8038_LDO27			188
+#define QCOM_RPM_PM8038_SMPS1			189
+#define QCOM_RPM_PM8038_SMPS2			190
+#define QCOM_RPM_PM8038_SMPS3			191
+#define QCOM_RPM_PM8038_SMPS4			192
+#define QCOM_RPM_PM8038_SMPS5			193
+#define QCOM_RPM_PM8038_SMPS6			194
+#define QCOM_RPM_PM8038_LVS1			195
+#define QCOM_RPM_PM8038_LVS2			196
+#define QCOM_RPM_PM8038_CLK1			197
+#define QCOM_RPM_PM8038_CLK2			198
+
 /*
  * Constants used to select force mode for regulators.
  */
diff --git a/include/dt-bindings/reset/qcom,gcc-msm8960.h b/include/dt-bindings/reset/qcom,gcc-msm8960.h
index 47c86869..499e834b 100644
--- a/include/dt-bindings/reset/qcom,gcc-msm8960.h
+++ b/include/dt-bindings/reset/qcom,gcc-msm8960.h
@@ -130,5 +130,6 @@
 #define CE3_SLEEP_RESET					113
 #define GSS_SLP_RESET					114
 #define GSS_RESET					115
+#define USB_PHY0_RESET				116
 
 #endif
